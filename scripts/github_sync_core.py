#!/usr/bin/env python3
"""Shared GitHub sync logic for Speckit and GSD frameworks.

Provides unified functions for:
- Label management (auto-creation with standard colors)
- ProjectsV2 support (create, validate, add items via GraphQL)
- Milestone management
- Issue operations

Usage:
    from github_sync_core import (
        ensure_labels_exist,
        ensure_project_exists,
        add_issue_to_project,
        get_project_by_name,
    )
"""

from __future__ import annotations

import json
import os
import subprocess
from dataclasses import dataclass


def get_project_owner(repo_owner: str) -> str:
    """Get the owner to use for project operations.

    Checks GH_PROJECT_ORG env var first, falls back to repo_owner.
    This allows projects to be created under a different org than the repo owner.

    Args:
        repo_owner: The repository owner (user or org)

    Returns:
        Owner to use for project operations
    """
    return os.environ.get("GH_PROJECT_ORG", repo_owner)


# =============================================================================
# Constants
# =============================================================================

# Standard labels with colors (hex without #)
STANDARD_LABELS = {
    "priority-p1": {"color": "b60205", "description": "High priority task"},
    "priority-p2": {"color": "fbca04", "description": "Medium priority task"},
    "priority-p3": {"color": "0e8a16", "description": "Low priority task"},
    "auto-generated": {"color": "c5def5", "description": "Auto-generated by SpecKit"},
    "parallelizable": {
        "color": "5319e7",
        "description": "Can be worked on in parallel",
    },
    "evolve": {"color": "bfdadc", "description": "Evolving/experimental task"},
    "todo": {"color": "d876e3", "description": "GSD todo item"},
    "gsd-phase": {"color": "0052cc", "description": "GSD phase"},
    "gsd-plan": {"color": "006b75", "description": "GSD plan"},
}

# Standard ProjectV2 columns for Kanban board (4 columns)
PROJECT_COLUMNS = [
    {"name": "Backlog", "color": "GRAY", "description": "Not started"},
    {"name": "In Progress", "color": "YELLOW", "description": "Being worked on"},
    {"name": "Review", "color": "PURPLE", "description": "In review"},
    {"name": "Done", "color": "GREEN", "description": "Completed"},
]


# =============================================================================
# Status & Progress Helpers
# =============================================================================


def get_status_from_checkbox(checkbox: str) -> tuple[str, str]:
    """Get status and Kanban column from checkbox character.

    Args:
        checkbox: Single character from markdown checkbox (space, x, X, ~)

    Returns:
        Tuple of (status, kanban_column):
        - ("completed", "Done") for [x] or [X]
        - ("in_progress", "In Progress") for [~]
        - ("pending", "Backlog") for [ ]
    """
    c = checkbox.upper() if checkbox else " "
    if c == "X":
        return ("completed", "Done")
    if c == "~":
        return ("in_progress", "In Progress")
    return ("pending", "Backlog")


def calculate_progress(items: list) -> dict:
    """Calculate progress statistics from a list of items with status attribute.

    Args:
        items: List of objects with a 'status' attribute

    Returns:
        Dict with keys: total, completed, in_progress, pending, percent
    """
    total = len(items)
    completed = sum(1 for i in items if getattr(i, "status", None) == "completed")
    in_progress = sum(1 for i in items if getattr(i, "status", None) == "in_progress")
    pending = total - completed - in_progress
    return {
        "total": total,
        "completed": completed,
        "in_progress": in_progress,
        "pending": pending,
        "percent": round(completed / total * 100) if total else 0,
    }


@dataclass
class ProjectInfo:
    """GitHub ProjectV2 information."""

    id: str
    number: int
    title: str
    url: str


# =============================================================================
# GitHub CLI Helpers
# =============================================================================


def run_gh_command(args: list[str], check: bool = True) -> tuple[int, str, str]:
    """Run a gh CLI command and return result."""
    try:
        result = subprocess.run(
            ["gh"] + args,
            capture_output=True,
            text=True,
            check=check,
        )
        return result.returncode, result.stdout, result.stderr
    except subprocess.CalledProcessError as e:
        return e.returncode, e.stdout, e.stderr
    except FileNotFoundError:
        return 1, "", "gh CLI not found"


def run_graphql_query(
    query: str, variables: dict | None = None, silent: bool = False
) -> dict | None:
    """Execute a GraphQL query against GitHub API.

    Args:
        query: GraphQL query string
        variables: Query variables
        silent: If True, don't print errors (useful for exploratory queries)
    """
    cmd = ["api", "graphql", "-f", f"query={query}"]
    if variables:
        for key, value in variables.items():
            cmd.extend(["-f", f"{key}={value}"])

    code, stdout, stderr = run_gh_command(cmd, check=False)
    if code != 0:
        if not silent:
            print(f"GraphQL error: {stderr}")
        # Try to parse anyway - partial data may be present
        try:
            result = json.loads(stdout) if stdout else None
            if result and result.get("data"):
                return result
        except json.JSONDecodeError:
            pass
        return None

    try:
        return json.loads(stdout)
    except json.JSONDecodeError:
        return None


def get_repo_info() -> tuple[str, str] | None:
    """Get current repository owner and name from git."""
    code, stdout, _ = run_gh_command(
        ["repo", "view", "--json", "owner,name", "-q", ".owner.login,.name"],
        check=False,
    )
    if code != 0 or not stdout:
        return None

    parts = stdout.strip().split("\n")
    if len(parts) >= 2:
        return parts[0], parts[1]
    return None


def get_repo_node_id() -> str | None:
    """Get the repository's GraphQL node ID."""
    code, stdout, _ = run_gh_command(
        ["repo", "view", "--json", "id", "-q", ".id"],
        check=False,
    )
    return stdout.strip() if code == 0 and stdout else None


# =============================================================================
# Label Management
# =============================================================================


def get_existing_labels() -> set[str]:
    """Get existing labels in the repository."""
    code, stdout, _ = run_gh_command(
        ["label", "list", "--json", "name", "-q", ".[].name"],
        check=False,
    )
    if code != 0:
        return set()
    return set(stdout.strip().split("\n")) if stdout.strip() else set()


def ensure_labels_exist(labels: list[str], dry_run: bool = False) -> list[str]:
    """Ensure required labels exist, creating any that are missing.

    Returns list of labels that were created.
    """
    existing = get_existing_labels()
    created = []

    for label in labels:
        if label in existing:
            continue

        # Check if it's a standard label with defined color
        if label in STANDARD_LABELS:
            label_config = STANDARD_LABELS[label]
            color = label_config["color"]
            description = label_config["description"]
        elif label.startswith("spec-"):
            # Spec labels get a standard color
            color = "1d76db"
            description = f"Related to {label}"
        elif label.startswith("phase-"):
            # Phase labels
            color = "0052cc"
            description = f"GSD {label}"
        elif label.startswith("milestone-"):
            # Milestone labels
            color = "5319e7"
            description = f"GSD {label}"
        elif label.startswith("priority-"):
            # Priority labels with traffic light colors
            priority = label.split("-", 1)[1]
            priority_colors = {
                "high": "d73a4a",  # Red
                "medium": "fbca04",  # Yellow
                "low": "0e8a16",  # Green
            }
            color = priority_colors.get(priority, "ededed")
            description = f"Priority: {priority}"
        elif label.startswith("effort-"):
            # Effort/size labels with gradient colors
            effort = label.split("-", 1)[1]
            effort_colors = {
                "XS": "c5def5",  # Light blue
                "S": "85bbf0",  # Blue
                "M": "4a8ed8",  # Medium blue
                "L": "1a5fb4",  # Dark blue
                "XL": "0d3a6e",  # Very dark blue
            }
            color = effort_colors.get(effort.upper(), "ededed")
            description = f"Effort: {effort}"
        elif label.startswith("sprint-"):
            # Sprint labels (blue color for time-based tracking)
            sprint = label.split("-", 1)[1]
            color = "1d76db"  # Blue
            description = f"Sprint: {sprint}"
        else:
            # Default for unknown labels
            color = "ededed"
            description = ""

        if dry_run:
            print(f"[DRY RUN] Would create label: {label}")
            created.append(label)
            continue

        cmd = ["label", "create", label, "--color", color]
        if description:
            cmd.extend(["--description", description])

        code, _, stderr = run_gh_command(cmd, check=False)
        if code == 0:
            print(f"Created label: {label}")
            created.append(label)
        else:
            # Label might already exist (race condition) or other error
            if "already exists" not in stderr.lower():
                print(f"Warning: Could not create label {label}: {stderr}")

    return created


# =============================================================================
# ProjectsV2 Management (GraphQL)
# =============================================================================


def get_project_by_name(owner: str, project_name: str) -> ProjectInfo | None:
    """Get a ProjectV2 by name using GraphQL.

    Args:
        owner: Repository owner (user or organization)
        project_name: Project title to search for

    Returns:
        ProjectInfo if found, None otherwise
    """
    # Query both user and organization projects
    query = """
    query($owner: String!, $projectName: String!) {
      user(login: $owner) {
        projectsV2(first: 100, query: $projectName) {
          nodes {
            id
            number
            title
            url
          }
        }
      }
      organization(login: $owner) {
        projectsV2(first: 100, query: $projectName) {
          nodes {
            id
            number
            title
            url
          }
        }
      }
    }
    """

    # Use silent=True because one of user/org will always fail
    result = run_graphql_query(
        query, {"owner": owner, "projectName": project_name}, silent=True
    )
    if not result:
        return None

    # Check user projects first, then organization
    for source in ["user", "organization"]:
        data = result.get("data", {}).get(source)
        if data and data.get("projectsV2", {}).get("nodes"):
            for project in data["projectsV2"]["nodes"]:
                if project["title"] == project_name:
                    return ProjectInfo(
                        id=project["id"],
                        number=project["number"],
                        title=project["title"],
                        url=project["url"],
                    )

    return None


def create_project(
    owner: str, project_name: str, dry_run: bool = False
) -> ProjectInfo | None:
    """Create a new ProjectV2 using GraphQL.

    Args:
        owner: Repository owner
        project_name: Title for the new project
        dry_run: If True, don't actually create

    Returns:
        ProjectInfo for the created project, None on failure
    """
    if dry_run:
        print(f"[DRY RUN] Would create project: {project_name}")
        return None

    # First, get the owner's node ID
    query = """
    query($owner: String!) {
      user(login: $owner) {
        id
      }
      organization(login: $owner) {
        id
      }
    }
    """

    # Use silent=True because one of user/org will always fail
    result = run_graphql_query(query, {"owner": owner}, silent=True)
    if not result:
        return None

    owner_id = None
    for source in ["user", "organization"]:
        data = result.get("data", {}).get(source)
        if data and data.get("id"):
            owner_id = data["id"]
            break

    if not owner_id:
        print(f"Could not find owner ID for {owner}")
        return None

    # Create the project
    mutation = """
    mutation($ownerId: ID!, $title: String!) {
      createProjectV2(input: {ownerId: $ownerId, title: $title}) {
        projectV2 {
          id
          number
          title
          url
        }
      }
    }
    """

    result = run_graphql_query(mutation, {"ownerId": owner_id, "title": project_name})
    if not result:
        return None

    project_data = result.get("data", {}).get("createProjectV2", {}).get("projectV2")
    if project_data:
        print(f"Created project: {project_name}")
        project_info = ProjectInfo(
            id=project_data["id"],
            number=project_data["number"],
            title=project_data["title"],
            url=project_data["url"],
        )
        # Configure 4-column Kanban board
        _configure_project_columns(project_info.id)
        return project_info

    return None


def _configure_project_columns(project_id: str) -> bool:
    """Configure project Status field with 4-column Kanban layout.

    Args:
        project_id: GraphQL node ID of the project

    Returns:
        True if successful
    """
    # Get the Status field ID
    query = """
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          field(name: "Status") {
            ... on ProjectV2SingleSelectField {
              id
            }
          }
        }
      }
    }
    """
    result = run_graphql_query(query, {"projectId": project_id}, silent=True)
    if not result:
        return False

    field_data = result.get("data", {}).get("node", {}).get("field")
    if not field_data or not field_data.get("id"):
        return False

    field_id = field_data["id"]

    # Build options from PROJECT_COLUMNS
    options_str = ", ".join(
        f'{{ name: "{col["name"]}", color: {col["color"]}, description: "{col["description"]}" }}'
        for col in PROJECT_COLUMNS
    )

    mutation = f"""
    mutation {{
      updateProjectV2Field(input: {{
        fieldId: "{field_id}"
        singleSelectOptions: [{options_str}]
      }}) {{
        projectV2Field {{
          ... on ProjectV2SingleSelectField {{
            options {{ name }}
          }}
        }}
      }}
    }}
    """

    result = run_graphql_query(mutation, silent=True)
    if result and result.get("data"):
        print("  Configured 4-column Kanban board")
        return True
    return False


def ensure_project_exists(
    owner: str, project_name: str, dry_run: bool = False
) -> ProjectInfo | None:
    """Ensure a ProjectV2 exists, creating if necessary.

    Args:
        owner: Repository owner (will check GH_PROJECT_ORG env var first)
        project_name: Project title
        dry_run: If True, don't create

    Returns:
        ProjectInfo for existing or newly created project
    """
    # Check GH_PROJECT_ORG env var for cross-org project support
    project_owner = get_project_owner(owner)
    if project_owner != owner:
        print(f"Using project owner from GH_PROJECT_ORG: {project_owner}")

    existing = get_project_by_name(project_owner, project_name)
    if existing:
        print(f"Project exists: {existing.title} (#{existing.number})")
        return existing

    return create_project(project_owner, project_name, dry_run)


def _get_status_field_info(project_id: str) -> tuple[str, str] | None:
    """Get Status field ID and Backlog option ID for a project.

    Returns:
        Tuple of (field_id, backlog_option_id) or None if not found
    """
    query = """
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          field(name: "Status") {
            ... on ProjectV2SingleSelectField {
              id
              options {
                id
                name
              }
            }
          }
        }
      }
    }
    """
    result = run_graphql_query(query, {"projectId": project_id})
    if not result:
        return None

    field = result.get("data", {}).get("node", {}).get("field")
    if not field:
        return None

    field_id = field.get("id")
    options = field.get("options", [])

    # Find "Backlog" option
    backlog_option_id = None
    for opt in options:
        if opt.get("name") == "Backlog":
            backlog_option_id = opt.get("id")
            break

    if field_id and backlog_option_id:
        return (field_id, backlog_option_id)
    return None


def _set_item_status(
    project_id: str, item_id: str, field_id: str, option_id: str
) -> bool:
    """Set the Status field for a project item.

    Returns:
        True if successful, False otherwise
    """
    mutation = """
    mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
      updateProjectV2ItemFieldValue(input: {
        projectId: $projectId
        itemId: $itemId
        fieldId: $fieldId
        value: {singleSelectOptionId: $optionId}
      }) {
        projectV2Item {
          id
        }
      }
    }
    """
    result = run_graphql_query(
        mutation,
        {
            "projectId": project_id,
            "itemId": item_id,
            "fieldId": field_id,
            "optionId": option_id,
        },
    )
    return result is not None and "errors" not in result


# Cache for status field info (project_id -> (field_id, backlog_option_id))
_status_field_cache: dict[str, tuple[str, str]] = {}


def add_issue_to_project(
    project_id: str, issue_node_id: str, dry_run: bool = False
) -> str | None:
    """Add an issue to a ProjectV2 using GraphQL and set status to Backlog.

    Args:
        project_id: GraphQL node ID of the project
        issue_node_id: GraphQL node ID of the issue
        dry_run: If True, don't actually add

    Returns:
        Item ID if successful, None otherwise
    """
    if dry_run:
        print("[DRY RUN] Would add issue to project (Backlog)")
        return None

    mutation = """
    mutation($projectId: ID!, $contentId: ID!) {
      addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
        item {
          id
        }
      }
    }
    """

    result = run_graphql_query(
        mutation, {"projectId": project_id, "contentId": issue_node_id}
    )
    if not result:
        return None

    item_data = result.get("data", {}).get("addProjectV2ItemById", {}).get("item")
    item_id = item_data.get("id") if item_data else None

    if not item_id:
        return None

    # Set status to Backlog
    if project_id not in _status_field_cache:
        field_info = _get_status_field_info(project_id)
        if field_info:
            _status_field_cache[project_id] = field_info

    if project_id in _status_field_cache:
        field_id, backlog_option_id = _status_field_cache[project_id]
        _set_item_status(project_id, item_id, field_id, backlog_option_id)

    return item_id


def get_issue_node_id(issue_number: int) -> str | None:
    """Get the GraphQL node ID for an issue by number."""
    code, stdout, _ = run_gh_command(
        ["issue", "view", str(issue_number), "--json", "id", "-q", ".id"],
        check=False,
    )
    return stdout.strip() if code == 0 and stdout else None


# =============================================================================
# Milestone Management
# =============================================================================


def get_existing_milestones(include_closed: bool = False) -> dict[str, int]:
    """Get existing milestones and their numbers.

    Args:
        include_closed: If True, include closed milestones too
    """
    # Use proper jq to get interleaved title,number pairs
    endpoint = "repos/{owner}/{repo}/milestones"
    if include_closed:
        endpoint += "?state=all"
    code, stdout, _ = run_gh_command(
        ["api", endpoint, "-q", ".[] | .title, .number"],
        check=False,
    )
    if code != 0:
        return {}

    milestones = {}
    lines = stdout.strip().split("\n")
    for i in range(0, len(lines) - 1, 2):
        if lines[i] and lines[i + 1]:
            try:
                milestones[lines[i]] = int(lines[i + 1])
            except ValueError:
                # If parsing fails, skip this milestone
                continue
    return milestones


def reopen_milestone(milestone_number: int) -> bool:
    """Reopen a closed milestone.

    Args:
        milestone_number: The milestone number to reopen

    Returns:
        True if successful
    """
    code, _, _ = run_gh_command(
        [
            "api",
            f"repos/{{owner}}/{{repo}}/milestones/{milestone_number}",
            "--method",
            "PATCH",
            "-f",
            "state=open",
        ],
        check=False,
    )
    return code == 0


def create_milestone(
    title: str, description: str = "", dry_run: bool = False
) -> int | None:
    """Create a GitHub milestone.

    Args:
        title: Milestone title
        description: Optional description
        dry_run: If True, don't actually create

    Returns:
        Milestone number if successful, None otherwise
    """
    if dry_run:
        print(f"[DRY RUN] Would create milestone: {title}")
        return None

    cmd = [
        "api",
        "repos/{owner}/{repo}/milestones",
        "--method",
        "POST",
        "-f",
        f"title={title}",
        "-f",
        "state=open",
        "-q",
        ".number",
    ]
    if description:
        cmd.extend(["-f", f"description={description}"])

    code, stdout, _ = run_gh_command(cmd, check=False)
    return int(stdout.strip()) if code == 0 and stdout else None


def ensure_milestone_exists(
    title: str, description: str = "", dry_run: bool = False
) -> int | None:
    """Ensure a milestone exists, creating or reopening if necessary.

    Returns:
        Milestone number
    """
    # First check open milestones
    existing = get_existing_milestones()
    if title in existing:
        print(f"Milestone exists: {title} (#{existing[title]})")
        return existing[title]

    # Check if there's a closed milestone with the same title
    all_milestones = get_existing_milestones(include_closed=True)
    if title in all_milestones:
        milestone_num = all_milestones[title]
        if dry_run:
            print(f"[DRY RUN] Would reopen milestone: {title} (#{milestone_num})")
            return milestone_num
        if reopen_milestone(milestone_num):
            print(f"Reopened milestone: {title} (#{milestone_num})")
            return milestone_num
        print(f"Failed to reopen milestone: {title}")
        return None

    # Create new milestone
    new_milestone_num = create_milestone(title, description, dry_run)
    if new_milestone_num:
        print(f"Created milestone: {title} (#{new_milestone_num})")
    return new_milestone_num


def close_milestone(milestone_number: int, dry_run: bool = False) -> bool:
    """Close a GitHub milestone.

    Args:
        milestone_number: The milestone number to close
        dry_run: If True, don't actually close

    Returns:
        True if successful, False otherwise
    """
    if dry_run:
        print(f"[DRY RUN] Would close milestone #{milestone_number}")
        return True

    cmd = [
        "api",
        f"repos/{{owner}}/{{repo}}/milestones/{milestone_number}",
        "--method",
        "PATCH",
        "-f",
        "state=closed",
    ]

    code, _, stderr = run_gh_command(cmd, check=False)
    if code != 0:
        print(f"Failed to close milestone #{milestone_number}: {stderr}")
        return False
    return True


def get_milestone_open_issues(milestone_number: int) -> int:
    """Get count of open issues in a milestone.

    Returns:
        Number of open issues, or -1 on error
    """
    cmd = [
        "api",
        f"repos/{{owner}}/{{repo}}/milestones/{milestone_number}",
        "-q",
        ".open_issues",
    ]

    code, stdout, _ = run_gh_command(cmd, check=False)
    if code != 0 or not stdout.strip():
        return -1
    try:
        return int(stdout.strip())
    except ValueError:
        return -1


# =============================================================================
# Issue Operations
# =============================================================================


def create_issue(
    title: str,
    body: str,
    labels: list[str] | None = None,
    milestone_num: int | None = None,
    project_id: str | None = None,
    dry_run: bool = False,
) -> int | None:
    """Create a GitHub issue and optionally link to project.

    Args:
        title: Issue title
        body: Issue body (markdown)
        labels: List of label names
        milestone_num: Milestone number to assign
        project_id: ProjectV2 node ID to add issue to
        dry_run: If True, don't actually create

    Returns:
        Issue number if successful, None otherwise
    """
    if dry_run:
        print(f"[DRY RUN] Would create issue: {title}")
        return None

    cmd = ["issue", "create", "--title", title, "--body", body]
    for label in labels or []:
        cmd.extend(["--label", label])
    if milestone_num:
        cmd.extend(["--milestone", str(milestone_num)])

    code, stdout, stderr = run_gh_command(cmd, check=False)
    if code != 0:
        print(f"Failed to create issue: {stderr}")
        return None

    # Extract issue number from URL
    import re

    match = re.search(r"/issues/(\d+)", stdout)
    if not match:
        return None

    issue_num = int(match.group(1))

    # Add to project if specified
    if project_id:
        issue_node_id = get_issue_node_id(issue_num)
        if issue_node_id:
            add_issue_to_project(project_id, issue_node_id, dry_run)

    return issue_num


def update_issue(
    issue_number: int,
    title: str | None = None,
    body: str | None = None,
    dry_run: bool = False,
) -> bool:
    """Update an existing GitHub issue title and/or body.

    Args:
        issue_number: Issue number to update
        title: New title (or None to keep existing)
        body: New body (or None to keep existing)
        dry_run: If True, don't actually update

    Returns:
        True if successful, False otherwise
    """
    if dry_run:
        print(f"[DRY RUN] Would update issue #{issue_number}: title={title}")
        return True

    cmd = ["issue", "edit", str(issue_number)]
    if title:
        cmd.extend(["--title", title])
    if body:
        cmd.extend(["--body", body])

    if len(cmd) == 3:  # No updates specified
        return True

    code, stdout, stderr = run_gh_command(cmd, check=False)
    if code != 0:
        print(f"Failed to update issue #{issue_number}: {stderr}")
        return False

    return True


def _get_status_option_id(project_id: str, status_name: str) -> str | None:
    """Get the option ID for a status value (e.g., 'Done', 'In Progress')."""
    query = """
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          field(name: "Status") {
            ... on ProjectV2SingleSelectField {
              id
              options {
                id
                name
              }
            }
          }
        }
      }
    }
    """
    result = run_graphql_query(query, {"projectId": project_id})
    if not result:
        return None

    field = result.get("data", {}).get("node", {}).get("field")
    if not field:
        return None

    for opt in field.get("options", []):
        if opt.get("name") == status_name:
            return opt.get("id")
    return None


def _get_project_item_id(project_id: str, issue_number: int) -> str | None:
    """Get the project item ID for an issue in a project."""
    query = """
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          items(first: 100) {
            nodes {
              id
              content {
                ... on Issue {
                  number
                }
              }
            }
          }
        }
      }
    }
    """
    result = run_graphql_query(query, {"projectId": project_id})
    if not result:
        return None

    items = result.get("data", {}).get("node", {}).get("items", {}).get("nodes", [])
    for item in items:
        content = item.get("content", {})
        if content and content.get("number") == issue_number:
            return item.get("id")
    return None


def set_issue_status(
    project_id: str, issue_number: int, status: str, dry_run: bool = False
) -> bool:
    """Set the Status field for an issue in a project.

    Args:
        project_id: GraphQL node ID of the project
        issue_number: Issue number
        status: Status name (e.g., "Done", "In Progress", "Backlog")
        dry_run: If True, don't make changes

    Returns:
        True if successful
    """
    if dry_run:
        print(f"[DRY RUN] Would set issue #{issue_number} status to {status}")
        return True

    # Get the item ID
    item_id = _get_project_item_id(project_id, issue_number)
    if not item_id:
        return False

    # Get field ID and option ID
    field_info = _get_status_field_info(project_id)
    if not field_info:
        return False
    field_id = field_info[0]

    # Get the option ID for the desired status
    option_id = _get_status_option_id(project_id, status)
    if not option_id:
        return False

    return _set_item_status(project_id, item_id, field_id, option_id)


def get_issue_status(project_id: str, issue_number: int) -> str | None:
    """Get the current Status of an issue in a project.

    Returns:
        Status name (e.g., "Done", "Backlog") or None if not found
    """
    query = """
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          items(first: 100) {
            nodes {
              content {
                ... on Issue {
                  number
                }
              }
              fieldValueByName(name: "Status") {
                ... on ProjectV2ItemFieldSingleSelectValue {
                  name
                }
              }
            }
          }
        }
      }
    }
    """
    result = run_graphql_query(query, {"projectId": project_id})
    if not result:
        return None

    items = result.get("data", {}).get("node", {}).get("items", {}).get("nodes", [])
    for item in items:
        content = item.get("content", {})
        if content and content.get("number") == issue_number:
            field_value = item.get("fieldValueByName")
            if field_value:
                return field_value.get("name")
    return None


def close_issue(
    issue_number: int, project_id: str | None = None, dry_run: bool = False
) -> bool:
    """Close a GitHub issue and optionally move to Done on project board.

    Args:
        issue_number: Issue number to close
        project_id: If provided, also move to Done status
        dry_run: If True, don't make changes

    Returns:
        True if successful
    """
    if dry_run:
        print(f"[DRY RUN] Would close issue #{issue_number}")
        if project_id:
            print(f"[DRY RUN] Would move #{issue_number} to Done")
        return True

    code, _, _ = run_gh_command(["issue", "close", str(issue_number)], check=False)

    # Move to Done on project board if project_id provided
    # Retry up to 3 times since GraphQL can be flaky
    if code == 0 and project_id:
        import time

        for attempt in range(3):
            if set_issue_status(project_id, issue_number, "Done", dry_run=False):
                break
            if attempt < 2:
                time.sleep(1)  # Wait before retry

    return code == 0


def get_existing_issues(label_filter: str | None = None) -> dict[str, dict]:
    """Get existing issues, optionally filtered by label.

    Returns dict mapping task/item ID to issue info.
    """
    import re

    query = "is:issue"
    if label_filter:
        query += f" label:{label_filter}"

    code, stdout, _ = run_gh_command(
        [
            "issue",
            "list",
            "--search",
            query,
            "--state",
            "all",
            "--limit",
            "500",
            "--json",
            "number,title,state,id",
        ],
        check=False,
    )
    if code != 0:
        return {}

    issues = {}
    try:
        data = json.loads(stdout) if stdout else []
        for issue in data:
            # Match task ID pattern (T\d+), plan/phase pattern, or UAT issue pattern
            match = re.search(
                r"(T\d+|Phase-\d+|Plan-[\w-]+|UAT-[\d-]+)", issue.get("title", "")
            )
            if match:
                issues[match.group(1)] = {
                    "number": issue["number"],
                    "state": issue["state"],
                    "title": issue["title"],
                    "node_id": issue.get("id"),
                }
    except json.JSONDecodeError:
        pass
    return issues


# =============================================================================
# Branch & PR Linking
# =============================================================================


def suggest_branch_name(task_id: str, description: str) -> str:
    """Generate branch name from task ID and description.

    Args:
        task_id: Task/Plan ID (e.g., "Plan-03-01", "T001")
        description: Task description

    Returns:
        Branch name like "feat/Plan-03-01-sofr-collector"

    Examples:
        >>> suggest_branch_name("Plan-03-01", "SOFR data collector")
        'feat/Plan-03-01-sofr-data-collector'
        >>> suggest_branch_name("T001", "Fix data model bug")
        'fix/T001-fix-data-model-bug'
    """
    import re

    # Create slug from description (lowercase, alphanumeric + hyphens, max 40 chars)
    slug = re.sub(r"[^a-z0-9]+", "-", description.lower()).strip("-")[:40].rstrip("-")

    # Determine prefix based on description content
    prefix = "feat"
    desc_lower = description.lower()
    if "fix" in desc_lower or "bug" in desc_lower:
        prefix = "fix"
    elif "refactor" in desc_lower:
        prefix = "refactor"
    elif "doc" in desc_lower:
        prefix = "docs"
    elif "test" in desc_lower:
        prefix = "test"

    return f"{prefix}/{task_id}-{slug}"


def get_linked_prs(issue_number: int) -> list[dict]:
    """Get PRs that close/reference this issue via GraphQL.

    Uses closingIssuesReferences to find PRs linked via "Closes #N" or similar.

    Args:
        issue_number: GitHub issue number

    Returns:
        List of dicts with PR info: number, title, state, url
    """
    # First get the issue node ID
    repo_info = get_repo_info()
    if not repo_info:
        return []

    owner, repo = repo_info

    query = """
    query($owner: String!, $repo: String!, $number: Int!) {
      repository(owner: $owner, name: $repo) {
        issue(number: $number) {
          timelineItems(first: 50, itemTypes: [CROSS_REFERENCED_EVENT, CONNECTED_EVENT]) {
            nodes {
              ... on CrossReferencedEvent {
                source {
                  ... on PullRequest {
                    number
                    title
                    state
                    url
                  }
                }
              }
              ... on ConnectedEvent {
                subject {
                  ... on PullRequest {
                    number
                    title
                    state
                    url
                  }
                }
              }
            }
          }
        }
      }
    }
    """

    result = run_graphql_query(
        query, {"owner": owner, "repo": repo, "number": str(issue_number)}
    )
    if not result:
        return []

    prs: list[dict] = []
    timeline = (
        result.get("data", {})
        .get("repository", {})
        .get("issue", {})
        .get("timelineItems", {})
        .get("nodes", [])
    )

    for item in timeline:
        # Handle CrossReferencedEvent
        source = item.get("source") or item.get("subject")
        if source and source.get("number"):
            pr_info = {
                "number": source["number"],
                "title": source.get("title", ""),
                "state": source.get("state", ""),
                "url": source.get("url", ""),
            }
            # Avoid duplicates
            if pr_info not in prs:
                prs.append(pr_info)

    return prs
