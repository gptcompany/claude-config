#!/usr/bin/env python3
"""Shared GitHub sync logic for Speckit and GSD frameworks.

Provides unified functions for:
- Label management (auto-creation with standard colors)
- ProjectsV2 support (create, validate, add items via GraphQL)
- Milestone management
- Issue operations

Usage:
    from github_sync_core import (
        ensure_labels_exist,
        ensure_project_exists,
        add_issue_to_project,
        get_project_by_name,
    )
"""

from __future__ import annotations

import json
import os
import subprocess
from dataclasses import dataclass


def get_project_owner(repo_owner: str) -> str:
    """Get the owner to use for project operations.

    Checks GH_PROJECT_ORG env var first, falls back to repo_owner.
    This allows projects to be created under a different org than the repo owner.

    Args:
        repo_owner: The repository owner (user or org)

    Returns:
        Owner to use for project operations
    """
    return os.environ.get("GH_PROJECT_ORG", repo_owner)


# =============================================================================
# Constants
# =============================================================================

# Standard labels with colors (hex without #)
STANDARD_LABELS = {
    "priority-p1": {"color": "b60205", "description": "High priority task"},
    "priority-p2": {"color": "fbca04", "description": "Medium priority task"},
    "priority-p3": {"color": "0e8a16", "description": "Low priority task"},
    "auto-generated": {"color": "c5def5", "description": "Auto-generated by SpecKit"},
    "parallelizable": {
        "color": "5319e7",
        "description": "Can be worked on in parallel",
    },
    "evolve": {"color": "bfdadc", "description": "Evolving/experimental task"},
    "todo": {"color": "d876e3", "description": "GSD todo item"},
    "gsd-phase": {"color": "0052cc", "description": "GSD phase"},
    "gsd-plan": {"color": "006b75", "description": "GSD plan"},
}

# Standard ProjectV2 columns for Kanban board (4 columns)
PROJECT_COLUMNS = [
    {"name": "Backlog", "color": "GRAY", "description": "Not started"},
    {"name": "In Progress", "color": "YELLOW", "description": "Being worked on"},
    {"name": "Review", "color": "PURPLE", "description": "In review"},
    {"name": "Done", "color": "GREEN", "description": "Completed"},
]


@dataclass
class ProjectInfo:
    """GitHub ProjectV2 information."""

    id: str
    number: int
    title: str
    url: str


# =============================================================================
# GitHub CLI Helpers
# =============================================================================


def run_gh_command(args: list[str], check: bool = True) -> tuple[int, str, str]:
    """Run a gh CLI command and return result."""
    try:
        result = subprocess.run(
            ["gh"] + args,
            capture_output=True,
            text=True,
            check=check,
        )
        return result.returncode, result.stdout, result.stderr
    except subprocess.CalledProcessError as e:
        return e.returncode, e.stdout, e.stderr
    except FileNotFoundError:
        return 1, "", "gh CLI not found"


def run_graphql_query(
    query: str, variables: dict | None = None, silent: bool = False
) -> dict | None:
    """Execute a GraphQL query against GitHub API.

    Args:
        query: GraphQL query string
        variables: Query variables
        silent: If True, don't print errors (useful for exploratory queries)
    """
    cmd = ["api", "graphql", "-f", f"query={query}"]
    if variables:
        for key, value in variables.items():
            cmd.extend(["-f", f"{key}={value}"])

    code, stdout, stderr = run_gh_command(cmd, check=False)
    if code != 0:
        if not silent:
            print(f"GraphQL error: {stderr}")
        # Try to parse anyway - partial data may be present
        try:
            result = json.loads(stdout) if stdout else None
            if result and result.get("data"):
                return result
        except json.JSONDecodeError:
            pass
        return None

    try:
        return json.loads(stdout)
    except json.JSONDecodeError:
        return None


def get_repo_info() -> tuple[str, str] | None:
    """Get current repository owner and name from git."""
    code, stdout, _ = run_gh_command(
        ["repo", "view", "--json", "owner,name", "-q", ".owner.login,.name"],
        check=False,
    )
    if code != 0 or not stdout:
        return None

    parts = stdout.strip().split("\n")
    if len(parts) >= 2:
        return parts[0], parts[1]
    return None


def get_repo_node_id() -> str | None:
    """Get the repository's GraphQL node ID."""
    code, stdout, _ = run_gh_command(
        ["repo", "view", "--json", "id", "-q", ".id"],
        check=False,
    )
    return stdout.strip() if code == 0 and stdout else None


# =============================================================================
# Label Management
# =============================================================================


def get_existing_labels() -> set[str]:
    """Get existing labels in the repository."""
    code, stdout, _ = run_gh_command(
        ["label", "list", "--json", "name", "-q", ".[].name"],
        check=False,
    )
    if code != 0:
        return set()
    return set(stdout.strip().split("\n")) if stdout.strip() else set()


def ensure_labels_exist(labels: list[str], dry_run: bool = False) -> list[str]:
    """Ensure required labels exist, creating any that are missing.

    Returns list of labels that were created.
    """
    existing = get_existing_labels()
    created = []

    for label in labels:
        if label in existing:
            continue

        # Check if it's a standard label with defined color
        if label in STANDARD_LABELS:
            label_config = STANDARD_LABELS[label]
            color = label_config["color"]
            description = label_config["description"]
        elif label.startswith("spec-"):
            # Spec labels get a standard color
            color = "1d76db"
            description = f"Related to {label}"
        elif label.startswith("phase-"):
            # Phase labels
            color = "0052cc"
            description = f"GSD {label}"
        elif label.startswith("milestone-"):
            # Milestone labels
            color = "5319e7"
            description = f"GSD {label}"
        else:
            # Default for unknown labels
            color = "ededed"
            description = ""

        if dry_run:
            print(f"[DRY RUN] Would create label: {label}")
            created.append(label)
            continue

        cmd = ["label", "create", label, "--color", color]
        if description:
            cmd.extend(["--description", description])

        code, _, stderr = run_gh_command(cmd, check=False)
        if code == 0:
            print(f"Created label: {label}")
            created.append(label)
        else:
            # Label might already exist (race condition) or other error
            if "already exists" not in stderr.lower():
                print(f"Warning: Could not create label {label}: {stderr}")

    return created


# =============================================================================
# ProjectsV2 Management (GraphQL)
# =============================================================================


def get_project_by_name(owner: str, project_name: str) -> ProjectInfo | None:
    """Get a ProjectV2 by name using GraphQL.

    Args:
        owner: Repository owner (user or organization)
        project_name: Project title to search for

    Returns:
        ProjectInfo if found, None otherwise
    """
    # Query both user and organization projects
    query = """
    query($owner: String!, $projectName: String!) {
      user(login: $owner) {
        projectsV2(first: 100, query: $projectName) {
          nodes {
            id
            number
            title
            url
          }
        }
      }
      organization(login: $owner) {
        projectsV2(first: 100, query: $projectName) {
          nodes {
            id
            number
            title
            url
          }
        }
      }
    }
    """

    # Use silent=True because one of user/org will always fail
    result = run_graphql_query(
        query, {"owner": owner, "projectName": project_name}, silent=True
    )
    if not result:
        return None

    # Check user projects first, then organization
    for source in ["user", "organization"]:
        data = result.get("data", {}).get(source)
        if data and data.get("projectsV2", {}).get("nodes"):
            for project in data["projectsV2"]["nodes"]:
                if project["title"] == project_name:
                    return ProjectInfo(
                        id=project["id"],
                        number=project["number"],
                        title=project["title"],
                        url=project["url"],
                    )

    return None


def create_project(
    owner: str, project_name: str, dry_run: bool = False
) -> ProjectInfo | None:
    """Create a new ProjectV2 using GraphQL.

    Args:
        owner: Repository owner
        project_name: Title for the new project
        dry_run: If True, don't actually create

    Returns:
        ProjectInfo for the created project, None on failure
    """
    if dry_run:
        print(f"[DRY RUN] Would create project: {project_name}")
        return None

    # First, get the owner's node ID
    query = """
    query($owner: String!) {
      user(login: $owner) {
        id
      }
      organization(login: $owner) {
        id
      }
    }
    """

    # Use silent=True because one of user/org will always fail
    result = run_graphql_query(query, {"owner": owner}, silent=True)
    if not result:
        return None

    owner_id = None
    for source in ["user", "organization"]:
        data = result.get("data", {}).get(source)
        if data and data.get("id"):
            owner_id = data["id"]
            break

    if not owner_id:
        print(f"Could not find owner ID for {owner}")
        return None

    # Create the project
    mutation = """
    mutation($ownerId: ID!, $title: String!) {
      createProjectV2(input: {ownerId: $ownerId, title: $title}) {
        projectV2 {
          id
          number
          title
          url
        }
      }
    }
    """

    result = run_graphql_query(mutation, {"ownerId": owner_id, "title": project_name})
    if not result:
        return None

    project_data = result.get("data", {}).get("createProjectV2", {}).get("projectV2")
    if project_data:
        print(f"Created project: {project_name}")
        project_info = ProjectInfo(
            id=project_data["id"],
            number=project_data["number"],
            title=project_data["title"],
            url=project_data["url"],
        )
        # Configure 4-column Kanban board
        _configure_project_columns(project_info.id)
        return project_info

    return None


def _configure_project_columns(project_id: str) -> bool:
    """Configure project Status field with 4-column Kanban layout.

    Args:
        project_id: GraphQL node ID of the project

    Returns:
        True if successful
    """
    # Get the Status field ID
    query = """
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          field(name: "Status") {
            ... on ProjectV2SingleSelectField {
              id
            }
          }
        }
      }
    }
    """
    result = run_graphql_query(query, {"projectId": project_id}, silent=True)
    if not result:
        return False

    field_data = result.get("data", {}).get("node", {}).get("field")
    if not field_data or not field_data.get("id"):
        return False

    field_id = field_data["id"]

    # Build options from PROJECT_COLUMNS
    options_str = ", ".join(
        f'{{ name: "{col["name"]}", color: {col["color"]}, description: "{col["description"]}" }}'
        for col in PROJECT_COLUMNS
    )

    mutation = f"""
    mutation {{
      updateProjectV2Field(input: {{
        fieldId: "{field_id}"
        singleSelectOptions: [{options_str}]
      }}) {{
        projectV2Field {{
          ... on ProjectV2SingleSelectField {{
            options {{ name }}
          }}
        }}
      }}
    }}
    """

    result = run_graphql_query(mutation, silent=True)
    if result and result.get("data"):
        print("  Configured 4-column Kanban board")
        return True
    return False


def ensure_project_exists(
    owner: str, project_name: str, dry_run: bool = False
) -> ProjectInfo | None:
    """Ensure a ProjectV2 exists, creating if necessary.

    Args:
        owner: Repository owner (will check GH_PROJECT_ORG env var first)
        project_name: Project title
        dry_run: If True, don't create

    Returns:
        ProjectInfo for existing or newly created project
    """
    # Check GH_PROJECT_ORG env var for cross-org project support
    project_owner = get_project_owner(owner)
    if project_owner != owner:
        print(f"Using project owner from GH_PROJECT_ORG: {project_owner}")

    existing = get_project_by_name(project_owner, project_name)
    if existing:
        print(f"Project exists: {existing.title} (#{existing.number})")
        return existing

    return create_project(project_owner, project_name, dry_run)


def _get_status_field_info(project_id: str) -> tuple[str, str] | None:
    """Get Status field ID and Backlog option ID for a project.

    Returns:
        Tuple of (field_id, backlog_option_id) or None if not found
    """
    query = """
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          field(name: "Status") {
            ... on ProjectV2SingleSelectField {
              id
              options {
                id
                name
              }
            }
          }
        }
      }
    }
    """
    result = run_graphql_query(query, {"projectId": project_id})
    if not result:
        return None

    field = result.get("data", {}).get("node", {}).get("field")
    if not field:
        return None

    field_id = field.get("id")
    options = field.get("options", [])

    # Find "Backlog" option
    backlog_option_id = None
    for opt in options:
        if opt.get("name") == "Backlog":
            backlog_option_id = opt.get("id")
            break

    if field_id and backlog_option_id:
        return (field_id, backlog_option_id)
    return None


def _set_item_status(
    project_id: str, item_id: str, field_id: str, option_id: str
) -> bool:
    """Set the Status field for a project item.

    Returns:
        True if successful, False otherwise
    """
    mutation = """
    mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
      updateProjectV2ItemFieldValue(input: {
        projectId: $projectId
        itemId: $itemId
        fieldId: $fieldId
        value: {singleSelectOptionId: $optionId}
      }) {
        projectV2Item {
          id
        }
      }
    }
    """
    result = run_graphql_query(
        mutation,
        {
            "projectId": project_id,
            "itemId": item_id,
            "fieldId": field_id,
            "optionId": option_id,
        },
    )
    return result is not None and "errors" not in result


# Cache for status field info (project_id -> (field_id, backlog_option_id))
_status_field_cache: dict[str, tuple[str, str]] = {}


def add_issue_to_project(
    project_id: str, issue_node_id: str, dry_run: bool = False
) -> str | None:
    """Add an issue to a ProjectV2 using GraphQL and set status to Backlog.

    Args:
        project_id: GraphQL node ID of the project
        issue_node_id: GraphQL node ID of the issue
        dry_run: If True, don't actually add

    Returns:
        Item ID if successful, None otherwise
    """
    if dry_run:
        print("[DRY RUN] Would add issue to project (Backlog)")
        return None

    mutation = """
    mutation($projectId: ID!, $contentId: ID!) {
      addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
        item {
          id
        }
      }
    }
    """

    result = run_graphql_query(
        mutation, {"projectId": project_id, "contentId": issue_node_id}
    )
    if not result:
        return None

    item_data = result.get("data", {}).get("addProjectV2ItemById", {}).get("item")
    item_id = item_data.get("id") if item_data else None

    if not item_id:
        return None

    # Set status to Backlog
    if project_id not in _status_field_cache:
        field_info = _get_status_field_info(project_id)
        if field_info:
            _status_field_cache[project_id] = field_info

    if project_id in _status_field_cache:
        field_id, backlog_option_id = _status_field_cache[project_id]
        _set_item_status(project_id, item_id, field_id, backlog_option_id)

    return item_id


def get_issue_node_id(issue_number: int) -> str | None:
    """Get the GraphQL node ID for an issue by number."""
    code, stdout, _ = run_gh_command(
        ["issue", "view", str(issue_number), "--json", "id", "-q", ".id"],
        check=False,
    )
    return stdout.strip() if code == 0 and stdout else None


# =============================================================================
# Milestone Management
# =============================================================================


def get_existing_milestones(include_closed: bool = False) -> dict[str, int]:
    """Get existing milestones and their numbers.

    Args:
        include_closed: If True, include closed milestones too
    """
    # Use proper jq to get interleaved title,number pairs
    endpoint = "repos/{owner}/{repo}/milestones"
    if include_closed:
        endpoint += "?state=all"
    code, stdout, _ = run_gh_command(
        ["api", endpoint, "-q", ".[] | .title, .number"],
        check=False,
    )
    if code != 0:
        return {}

    milestones = {}
    lines = stdout.strip().split("\n")
    for i in range(0, len(lines) - 1, 2):
        if lines[i] and lines[i + 1]:
            try:
                milestones[lines[i]] = int(lines[i + 1])
            except ValueError:
                # If parsing fails, skip this milestone
                continue
    return milestones


def reopen_milestone(milestone_number: int) -> bool:
    """Reopen a closed milestone.

    Args:
        milestone_number: The milestone number to reopen

    Returns:
        True if successful
    """
    code, _, _ = run_gh_command(
        [
            "api",
            f"repos/{{owner}}/{{repo}}/milestones/{milestone_number}",
            "--method",
            "PATCH",
            "-f",
            "state=open",
        ],
        check=False,
    )
    return code == 0


def create_milestone(
    title: str, description: str = "", dry_run: bool = False
) -> int | None:
    """Create a GitHub milestone.

    Args:
        title: Milestone title
        description: Optional description
        dry_run: If True, don't actually create

    Returns:
        Milestone number if successful, None otherwise
    """
    if dry_run:
        print(f"[DRY RUN] Would create milestone: {title}")
        return None

    cmd = [
        "api",
        "repos/{owner}/{repo}/milestones",
        "--method",
        "POST",
        "-f",
        f"title={title}",
        "-f",
        "state=open",
        "-q",
        ".number",
    ]
    if description:
        cmd.extend(["-f", f"description={description}"])

    code, stdout, _ = run_gh_command(cmd, check=False)
    return int(stdout.strip()) if code == 0 and stdout else None


def ensure_milestone_exists(
    title: str, description: str = "", dry_run: bool = False
) -> int | None:
    """Ensure a milestone exists, creating or reopening if necessary.

    Returns:
        Milestone number
    """
    # First check open milestones
    existing = get_existing_milestones()
    if title in existing:
        print(f"Milestone exists: {title} (#{existing[title]})")
        return existing[title]

    # Check if there's a closed milestone with the same title
    all_milestones = get_existing_milestones(include_closed=True)
    if title in all_milestones:
        milestone_num = all_milestones[title]
        if dry_run:
            print(f"[DRY RUN] Would reopen milestone: {title} (#{milestone_num})")
            return milestone_num
        if reopen_milestone(milestone_num):
            print(f"Reopened milestone: {title} (#{milestone_num})")
            return milestone_num
        print(f"Failed to reopen milestone: {title}")
        return None

    # Create new milestone
    new_milestone_num = create_milestone(title, description, dry_run)
    if new_milestone_num:
        print(f"Created milestone: {title} (#{new_milestone_num})")
    return new_milestone_num


def close_milestone(milestone_number: int, dry_run: bool = False) -> bool:
    """Close a GitHub milestone.

    Args:
        milestone_number: The milestone number to close
        dry_run: If True, don't actually close

    Returns:
        True if successful, False otherwise
    """
    if dry_run:
        print(f"[DRY RUN] Would close milestone #{milestone_number}")
        return True

    cmd = [
        "api",
        f"repos/{{owner}}/{{repo}}/milestones/{milestone_number}",
        "--method",
        "PATCH",
        "-f",
        "state=closed",
    ]

    code, _, stderr = run_gh_command(cmd, check=False)
    if code != 0:
        print(f"Failed to close milestone #{milestone_number}: {stderr}")
        return False
    return True


def get_milestone_open_issues(milestone_number: int) -> int:
    """Get count of open issues in a milestone.

    Returns:
        Number of open issues, or -1 on error
    """
    cmd = [
        "api",
        f"repos/{{owner}}/{{repo}}/milestones/{milestone_number}",
        "-q",
        ".open_issues",
    ]

    code, stdout, _ = run_gh_command(cmd, check=False)
    if code != 0 or not stdout.strip():
        return -1
    try:
        return int(stdout.strip())
    except ValueError:
        return -1


# =============================================================================
# Issue Operations
# =============================================================================


def create_issue(
    title: str,
    body: str,
    labels: list[str] | None = None,
    milestone_num: int | None = None,
    project_id: str | None = None,
    dry_run: bool = False,
) -> int | None:
    """Create a GitHub issue and optionally link to project.

    Args:
        title: Issue title
        body: Issue body (markdown)
        labels: List of label names
        milestone_num: Milestone number to assign
        project_id: ProjectV2 node ID to add issue to
        dry_run: If True, don't actually create

    Returns:
        Issue number if successful, None otherwise
    """
    if dry_run:
        print(f"[DRY RUN] Would create issue: {title}")
        return None

    cmd = ["issue", "create", "--title", title, "--body", body]
    for label in labels or []:
        cmd.extend(["--label", label])
    if milestone_num:
        cmd.extend(["--milestone", str(milestone_num)])

    code, stdout, stderr = run_gh_command(cmd, check=False)
    if code != 0:
        print(f"Failed to create issue: {stderr}")
        return None

    # Extract issue number from URL
    import re

    match = re.search(r"/issues/(\d+)", stdout)
    if not match:
        return None

    issue_num = int(match.group(1))

    # Add to project if specified
    if project_id:
        issue_node_id = get_issue_node_id(issue_num)
        if issue_node_id:
            add_issue_to_project(project_id, issue_node_id, dry_run)

    return issue_num


def _get_status_option_id(project_id: str, status_name: str) -> str | None:
    """Get the option ID for a status value (e.g., 'Done', 'In Progress')."""
    query = """
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          field(name: "Status") {
            ... on ProjectV2SingleSelectField {
              id
              options {
                id
                name
              }
            }
          }
        }
      }
    }
    """
    result = run_graphql_query(query, {"projectId": project_id})
    if not result:
        return None

    field = result.get("data", {}).get("node", {}).get("field")
    if not field:
        return None

    for opt in field.get("options", []):
        if opt.get("name") == status_name:
            return opt.get("id")
    return None


def _get_project_item_id(project_id: str, issue_number: int) -> str | None:
    """Get the project item ID for an issue in a project."""
    query = """
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          items(first: 100) {
            nodes {
              id
              content {
                ... on Issue {
                  number
                }
              }
            }
          }
        }
      }
    }
    """
    result = run_graphql_query(query, {"projectId": project_id})
    if not result:
        return None

    items = result.get("data", {}).get("node", {}).get("items", {}).get("nodes", [])
    for item in items:
        content = item.get("content", {})
        if content and content.get("number") == issue_number:
            return item.get("id")
    return None


def set_issue_status(
    project_id: str, issue_number: int, status: str, dry_run: bool = False
) -> bool:
    """Set the Status field for an issue in a project.

    Args:
        project_id: GraphQL node ID of the project
        issue_number: Issue number
        status: Status name (e.g., "Done", "In Progress", "Backlog")
        dry_run: If True, don't make changes

    Returns:
        True if successful
    """
    if dry_run:
        print(f"[DRY RUN] Would set issue #{issue_number} status to {status}")
        return True

    # Get the item ID
    item_id = _get_project_item_id(project_id, issue_number)
    if not item_id:
        return False

    # Get field ID and option ID
    field_info = _get_status_field_info(project_id)
    if not field_info:
        return False
    field_id = field_info[0]

    # Get the option ID for the desired status
    option_id = _get_status_option_id(project_id, status)
    if not option_id:
        return False

    return _set_item_status(project_id, item_id, field_id, option_id)


def get_issue_status(project_id: str, issue_number: int) -> str | None:
    """Get the current Status of an issue in a project.

    Returns:
        Status name (e.g., "Done", "Backlog") or None if not found
    """
    query = """
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          items(first: 100) {
            nodes {
              content {
                ... on Issue {
                  number
                }
              }
              fieldValueByName(name: "Status") {
                ... on ProjectV2ItemFieldSingleSelectValue {
                  name
                }
              }
            }
          }
        }
      }
    }
    """
    result = run_graphql_query(query, {"projectId": project_id})
    if not result:
        return None

    items = result.get("data", {}).get("node", {}).get("items", {}).get("nodes", [])
    for item in items:
        content = item.get("content", {})
        if content and content.get("number") == issue_number:
            field_value = item.get("fieldValueByName")
            if field_value:
                return field_value.get("name")
    return None


def close_issue(
    issue_number: int, project_id: str | None = None, dry_run: bool = False
) -> bool:
    """Close a GitHub issue and optionally move to Done on project board.

    Args:
        issue_number: Issue number to close
        project_id: If provided, also move to Done status
        dry_run: If True, don't make changes

    Returns:
        True if successful
    """
    if dry_run:
        print(f"[DRY RUN] Would close issue #{issue_number}")
        if project_id:
            print(f"[DRY RUN] Would move #{issue_number} to Done")
        return True

    code, _, _ = run_gh_command(["issue", "close", str(issue_number)], check=False)

    # Move to Done on project board if project_id provided
    # Retry up to 3 times since GraphQL can be flaky
    if code == 0 and project_id:
        import time

        for attempt in range(3):
            if set_issue_status(project_id, issue_number, "Done", dry_run=False):
                break
            if attempt < 2:
                time.sleep(1)  # Wait before retry

    return code == 0


def get_existing_issues(label_filter: str | None = None) -> dict[str, dict]:
    """Get existing issues, optionally filtered by label.

    Returns dict mapping task/item ID to issue info.
    """
    import re

    query = "is:issue"
    if label_filter:
        query += f" label:{label_filter}"

    code, stdout, _ = run_gh_command(
        [
            "issue",
            "list",
            "--search",
            query,
            "--state",
            "all",
            "--limit",
            "500",
            "--json",
            "number,title,state,id",
        ],
        check=False,
    )
    if code != 0:
        return {}

    issues = {}
    try:
        data = json.loads(stdout) if stdout else []
        for issue in data:
            # Match task ID pattern (T\d+) or plan/phase pattern
            match = re.search(r"(T\d+|Phase-\d+|Plan-[\w-]+)", issue.get("title", ""))
            if match:
                issues[match.group(1)] = {
                    "number": issue["number"],
                    "state": issue["state"],
                    "title": issue["title"],
                    "node_id": issue.get("id"),
                }
    except json.JSONDecodeError:
        pass
    return issues
