---
phase: 13-ecc-integration
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - ~/.claude/skills/validate.md
  - ~/.claude/templates/validation/orchestrator.py
autonomous: true
---

<objective>
Create unified `/validate` skill that wraps ValidationOrchestrator for easy invocation.

Purpose: Provide a single command for running validation (replaces manual pytest/orchestrator calls).
Output: /validate skill with tier filtering and nice terminal output.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-ecc-integration/13-RESEARCH.md
@.planning/phases/13-ecc-integration/13-01-SUMMARY.md
@~/.claude/templates/validation/orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /validate skill definition</name>
  <files>~/.claude/skills/validate.md</files>
  <action>
Create skill file at `~/.claude/skills/validate.md`:

```markdown
# /validate - Unified Validation Command

Run the 14-dimension ValidationOrchestrator.

## Usage

- `/validate` - Run all tiers (full validation)
- `/validate 1` or `/validate quick` - Run Tier 1 blockers only
- `/validate 2` - Run Tier 2 warnings only
- `/validate 3` - Run Tier 3 monitors only

## What it does

1. Loads validation config from `.claude/validation/config.json`
2. Runs ValidationOrchestrator with specified tier filter
3. Outputs results using TerminalReporter (rich if available)
4. Returns exit code: 0 if passed, 1 if Tier 1 failures

## Tier Summary

| Tier | Purpose | Behavior |
|------|---------|----------|
| 1 | Blockers | MUST pass - blocks CI/merge |
| 2 | Warnings | SHOULD fix - agents suggest fixes |
| 3 | Monitors | Track metrics - emit to Grafana |

## Exit Codes

- 0: All specified tiers passed
- 1: Tier 1 blockers failed
- 2: Validation error (config not found, etc.)
```

This is the skill definition (not implementation - orchestrator has the logic).
  </action>
  <verify>test -f ~/.claude/skills/validate.md && grep -q "Tier 1" ~/.claude/skills/validate.md</verify>
  <done>validate.md skill definition created with usage docs</done>
</task>

<task type="auto">
  <name>Task 2: Add run_from_cli method to orchestrator</name>
  <files>~/.claude/templates/validation/orchestrator.py</files>
  <action>
Add a `run_from_cli(tier: str | None = None)` method to ValidationOrchestrator:

1. Parse tier argument: None/"all" → run_all(), "1"/"quick" → run_tier(BLOCKER), "2" → run_tier(WARNING), "3" → run_tier(MONITOR)
2. Use TerminalReporter (from validators/confidence_loop/terminal_reporter.py) for output
3. Return exit code: 0 if passed, 1 if blockers failed, 2 on error

Add `if __name__ == "__main__":` block:
```python
if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Run validation orchestrator")
    parser.add_argument("tier", nargs="?", default=None, help="Tier to run (1/quick, 2, 3, or all)")
    args = parser.parse_args()

    orchestrator = ValidationOrchestrator()
    exit_code = asyncio.run(orchestrator.run_from_cli(args.tier))
    sys.exit(exit_code)
```

This enables: `python orchestrator.py 1` for quick validation.
  </action>
  <verify>python ~/.claude/templates/validation/orchestrator.py --help</verify>
  <done>orchestrator.py runnable as CLI with tier argument</done>
</task>

<task type="auto">
  <name>Task 3: Register ECC validators in VALIDATOR_REGISTRY</name>
  <files>~/.claude/templates/validation/orchestrator.py</files>
  <action>
Update orchestrator.py to register the new ECC validators:

1. Add import at top (with try/except for graceful degradation):
```python
try:
    from validators.ecc import (
        E2EValidator,
        SecurityEnhancedValidator,
        TDDValidator,
        EvalValidator,
    )
    ECC_VALIDATORS_AVAILABLE = True
except ImportError:
    ECC_VALIDATORS_AVAILABLE = False
```

2. Add to VALIDATOR_REGISTRY (existing pattern):
```python
if ECC_VALIDATORS_AVAILABLE:
    VALIDATOR_REGISTRY.update({
        "e2e_validation": E2EValidator,
        "security_enhanced": SecurityEnhancedValidator,
        "tdd_compliance": TDDValidator,
        "eval_metrics": EvalValidator,
    })
```

3. Update DIMENSIONS_CONFIG docstring to mention new dimensions

This follows the existing graceful degradation pattern used for other optional validators.
  </action>
  <verify>python -c "from orchestrator import VALIDATOR_REGISTRY; print('e2e_validation' in VALIDATOR_REGISTRY or 'ECC not available')"</verify>
  <done>ECC validators registered in orchestrator (if available)</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `/validate` skill definition exists at ~/.claude/skills/validate.md
- [ ] `python orchestrator.py --help` shows usage
- [ ] `python orchestrator.py 1` runs Tier 1 validation
- [ ] ECC validators registered if import succeeds
- [ ] Graceful degradation if ECC validators not found
</verification>

<success_criteria>

- /validate skill documented and ready for use
- Orchestrator runnable as CLI tool
- ECC validators integrated with graceful fallback
- Existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-ecc-integration/13-03-SUMMARY.md`
</output>
