---
phase: 19-production-hardening
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - ~/.claude/templates/validation/resilience/__init__.py
  - ~/.claude/templates/validation/resilience/cache.py
  - ~/.claude/templates/validation/tests/test_cache.py
  - ~/.claude/templates/validation/orchestrator.py
  - ~/.claude/templates/validation/orchestrator.py.j2
autonomous: true
domain: python-asyncio
---

<objective>
Implement incremental validation with file hash-based caching for 5x+ speedup on unchanged files.

Purpose: Every validation run re-validates all files, wasting time and resources. With caching, only changed files get validated. Cache invalidation based on content hash + config hash ensures correctness.

Output: `~/.claude/templates/validation/resilience/cache.py` with ValidationCache class, integrated into orchestrator, 12 tests passing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-production-hardening/19-RESEARCH.md
@.planning/phases/19-production-hardening/19-01-SUMMARY.md
@~/.claude/templates/validation/orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ValidationCache with diskcache</name>
  <files>~/.claude/templates/validation/resilience/__init__.py, ~/.claude/templates/validation/resilience/cache.py</files>
  <action>
1. Create `resilience/__init__.py` with exports:
   ```python
   from .cache import ValidationCache, CACHE_AVAILABLE
   __all__ = ["ValidationCache", "CACHE_AVAILABLE"]
   ```

2. Create `resilience/cache.py` with ValidationCache class:
   - Dependencies: `diskcache`, `xxhash` (optional fallback to hashlib.md5)
   - CACHE_AVAILABLE flag (False if diskcache not installed)

   Class ValidationCache:
   ```python
   def __init__(self, cache_dir: Path = Path.home() / ".cache" / "validation"):
       """Initialize disk cache. Creates directory if needed."""

   def set_config_hash(self, config: dict) -> None:
       """Update config hash. Changing config invalidates all cached results."""

   def _file_hash(self, path: Path) -> str:
       """Fast content hash using xxhash (or md5 fallback)."""

   def _cache_key(self, file_path: Path, dimension: str) -> str:
       """Key = file_hash:config_hash:dimension"""

   def get(self, file_path: Path, dimension: str) -> ValidationResult | None:
       """Get cached result if file unchanged. Returns None if not cached or stale."""

   def set(self, file_path: Path, dimension: str, result: ValidationResult, ttl: int = 86400):
       """Cache result with 24h default TTL."""

   def invalidate_all(self) -> int:
       """Clear entire cache. Returns count of cleared items."""

   def stats(self) -> dict:
       """Return cache statistics: hits, misses, size_bytes."""
   ```

3. Handle graceful degradation:
   - If diskcache not installed, ValidationCache methods become no-ops
   - get() always returns None
   - set() does nothing
   - CACHE_AVAILABLE = False

4. Use diskcache with stampede protection via `@dc.barrier` for concurrent access.

Do NOT add xxhash to required dependencies - use hashlib.md5 as fallback.
  </action>
  <verify>python -c "from resilience.cache import ValidationCache, CACHE_AVAILABLE; print(CACHE_AVAILABLE)"</verify>
  <done>ValidationCache class with file hash caching and graceful degradation</done>
</task>

<task type="auto">
  <name>Task 2: Integrate cache into orchestrator</name>
  <files>~/.claude/templates/validation/orchestrator.py, ~/.claude/templates/validation/orchestrator.py.j2</files>
  <action>
1. Add import with graceful fallback at top of orchestrator.py:
   ```python
   try:
       from resilience.cache import ValidationCache, CACHE_AVAILABLE
   except ImportError:
       CACHE_AVAILABLE = False
       ValidationCache = None
   ```

2. Add cache initialization in ValidationOrchestrator.__init__:
   ```python
   self.cache = ValidationCache() if CACHE_AVAILABLE else None
   if self.cache and self.config:
       self.cache.set_config_hash(self.config)
   ```

3. Modify _run_validator (or equivalent) to check cache:
   ```python
   async def _run_validator_cached(self, validator, file_path: Path | None = None):
       """Run validator with cache check."""
       # Skip cache for validators without file context
       if not file_path or not self.cache:
           return await validator.validate()

       # Check cache
       cached = self.cache.get(file_path, validator.dimension)
       if cached:
           logger.debug(f"Cache hit: {validator.dimension} for {file_path}")
           return cached

       # Run and cache
       result = await validator.validate()
       self.cache.set(file_path, validator.dimension, result)
       return result
   ```

4. Add cache control methods:
   ```python
   def clear_cache(self) -> int:
       """Clear validation cache. Returns count of cleared items."""
       if self.cache:
           return self.cache.invalidate_all()
       return 0

   def cache_stats(self) -> dict:
       """Get cache statistics."""
       if self.cache:
           return self.cache.stats()
       return {"available": False}
   ```

5. Update orchestrator.py.j2 template with same changes (maintain parity).

6. Add environment variable to disable cache: `VALIDATION_CACHE_ENABLED`
   ```python
   CACHE_ENABLED = os.environ.get("VALIDATION_CACHE_ENABLED", "true").lower() == "true"
   # Only use cache if available AND enabled
   self.cache = ValidationCache() if (CACHE_AVAILABLE and CACHE_ENABLED) else None
   ```
  </action>
  <verify>python -c "from orchestrator import ValidationOrchestrator; o = ValidationOrchestrator(); print(o.cache_stats())"</verify>
  <done>Orchestrator uses cache for incremental validation with env var control</done>
</task>

<task type="auto">
  <name>Task 3: Create cache tests</name>
  <files>~/.claude/templates/validation/tests/test_cache.py</files>
  <action>
Create comprehensive test file with 12 tests:

**Unit tests for ValidationCache:**
1. `test_cache_basic_set_get` - Set result, get it back
2. `test_cache_miss_on_file_change` - Change file content, cache misses
3. `test_cache_miss_on_config_change` - Change config hash, cache misses
4. `test_cache_ttl_expiry` - Expired entries return None
5. `test_cache_invalidate_all` - Clear cache works
6. `test_cache_stats` - Stats return correct values
7. `test_cache_graceful_without_diskcache` - Works when diskcache not installed (mock)

**Integration tests with orchestrator:**
8. `test_orchestrator_cache_hit` - Second run uses cache
9. `test_orchestrator_cache_disabled_env` - VALIDATION_CACHE_ENABLED=false skips cache
10. `test_orchestrator_clear_cache` - clear_cache() method works
11. `test_orchestrator_no_cache_for_fileless_validators` - Validators without file context skip cache
12. `test_cache_concurrent_access` - Multiple async validators don't corrupt cache

Tests should:
- Use tempfile for cache directory (not pollute real cache)
- Mock diskcache for "not installed" test
- Use @pytest.mark.asyncio for async tests
- Clean up temp files in teardown
  </action>
  <verify>pytest tests/test_cache.py -v shows 12 tests passing</verify>
  <done>12 cache tests covering unit and integration scenarios</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from resilience.cache import ValidationCache"` works
- [ ] `pytest tests/test_cache.py -v` shows 12 tests passing
- [ ] Cache provides 5x+ speedup on repeated validation (manual test)
- [ ] VALIDATION_CACHE_ENABLED=false disables cache
- [ ] orchestrator.py and orchestrator.py.j2 are in sync
</verification>

<success_criteria>
- ValidationCache class with file hash + config hash keys
- Graceful degradation when diskcache not installed
- 12 tests passing
- Environment variable control
- No breaking changes to existing orchestrator tests
</success_criteria>

<output>
After completion, create `.planning/phases/19-production-hardening/19-02-SUMMARY.md`
</output>
