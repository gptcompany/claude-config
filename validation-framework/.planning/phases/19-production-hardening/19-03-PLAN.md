---
phase: 19-production-hardening
plan: 03
type: execute
wave: 3
depends_on: ["19-01", "19-02"]
files_modified:
  - ~/.claude/templates/validation/resilience/circuit_breaker.py
  - ~/.claude/templates/validation/resilience/timeout.py
  - ~/.claude/templates/validation/resilience/__init__.py
  - ~/.claude/templates/validation/orchestrator.py
  - ~/.claude/templates/validation/orchestrator.py.j2
  - ~/.claude/templates/validation/tests/test_resilience.py
autonomous: true
domain: python-asyncio
---

<objective>
Implement resilience layer with circuit breaker, configurable timeouts, retry logic, and graceful degradation for partial results.

Purpose: Merge original 19-03 (timeout/retry/circuit breaker) and 19-04 (error recovery/graceful degradation) into single cohesive plan. When validators fail, timeout, or external services (MCP, QuestDB) are unavailable, the system handles it gracefully instead of crashing or hanging.

Output: Resilience module with circuit breaker and timeout wrappers, integrated into orchestrator, 18 tests passing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-production-hardening/19-RESEARCH.md
@.planning/phases/19-production-hardening/19-02-SUMMARY.md
@~/.claude/templates/validation/orchestrator.py
@~/.claude/templates/validation/resilience/cache.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create circuit breaker and timeout modules</name>
  <files>~/.claude/templates/validation/resilience/circuit_breaker.py, ~/.claude/templates/validation/resilience/timeout.py, ~/.claude/templates/validation/resilience/__init__.py</files>
  <action>
1. Create `resilience/circuit_breaker.py`:
   ```python
   """Circuit breaker for external service calls (MCP, QuestDB, Prometheus)."""
   from dataclasses import dataclass, field
   from datetime import datetime, timedelta
   from enum import Enum
   from typing import TypeVar, Callable, Awaitable

   class CircuitState(Enum):
       CLOSED = "closed"      # Normal operation
       OPEN = "open"          # Failing, reject calls
       HALF_OPEN = "half_open"  # Testing recovery

   @dataclass
   class CircuitBreaker:
       name: str
       fail_max: int = 5           # Failures before opening
       reset_timeout: timedelta = field(default_factory=lambda: timedelta(seconds=60))
       failures: int = 0
       last_failure: datetime | None = None
       state: CircuitState = CircuitState.CLOSED

       def record_failure(self) -> None:
           """Record a failure. May transition to OPEN."""

       def record_success(self) -> None:
           """Record success. Resets failures, transitions HALF_OPEN -> CLOSED."""

       def should_attempt(self) -> bool:
           """Check if call should be attempted based on circuit state."""

       def __repr__(self) -> str:
           return f"CircuitBreaker({self.name}, state={self.state.value}, failures={self.failures})"

   class CircuitOpenError(Exception):
       """Raised when circuit is open and call is rejected."""
       pass

   # Global registry of circuit breakers
   _BREAKERS: dict[str, CircuitBreaker] = {}

   def get_breaker(name: str, **kwargs) -> CircuitBreaker:
       """Get or create circuit breaker by name."""

   def reset_all_breakers() -> None:
       """Reset all circuit breakers (for testing)."""
   ```

2. Create `resilience/timeout.py`:
   ```python
   """Configurable timeout wrapper with retry support using tenacity."""
   import asyncio
   from functools import wraps
   from typing import TypeVar, Callable, Awaitable
   from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

   T = TypeVar("T")

   # Default timeouts per validator type (seconds)
   DEFAULT_TIMEOUTS = {
       "code_quality": 60,      # ruff can be slow on large codebases
       "type_safety": 120,      # pyright is slow
       "security": 90,          # bandit + gitleaks
       "coverage": 300,         # pytest coverage can be very slow
       "lint": 60,
       "visual": 30,            # screenshot comparison
       "behavioral": 30,        # DOM diff
       "default": 60,
   }

   def get_timeout(dimension: str, config: dict | None = None) -> float:
       """Get timeout for dimension from config or defaults."""

   async def with_timeout(
       coro: Awaitable[T],
       timeout: float,
       dimension: str = "unknown"
   ) -> T:
       """Wrap coroutine with timeout. Raises asyncio.TimeoutError on timeout."""

   def retry_with_breaker(
       breaker_name: str,
       max_attempts: int = 3,
       exceptions: tuple = (ConnectionError, TimeoutError),
   ) -> Callable:
       """Decorator: retry with exponential backoff and circuit breaker.

       Usage:
           @retry_with_breaker("mcp")
           async def call_mcp():
               ...
       """
   ```

3. Update `resilience/__init__.py`:
   ```python
   from .cache import ValidationCache, CACHE_AVAILABLE
   from .circuit_breaker import CircuitBreaker, CircuitOpenError, get_breaker, reset_all_breakers
   from .timeout import get_timeout, with_timeout, retry_with_breaker, DEFAULT_TIMEOUTS

   __all__ = [
       "ValidationCache", "CACHE_AVAILABLE",
       "CircuitBreaker", "CircuitOpenError", "get_breaker", "reset_all_breakers",
       "get_timeout", "with_timeout", "retry_with_breaker", "DEFAULT_TIMEOUTS",
   ]
   ```

Use tenacity for retry logic (already in research as recommended library).
Circuit breaker is custom implementation (simpler than adding purgatory dependency).
  </action>
  <verify>python -c "from resilience import CircuitBreaker, get_timeout, with_timeout; print('OK')"</verify>
  <done>Circuit breaker and timeout modules with tenacity retry integration</done>
</task>

<task type="auto">
  <name>Task 2: Integrate resilience into orchestrator</name>
  <files>~/.claude/templates/validation/orchestrator.py, ~/.claude/templates/validation/orchestrator.py.j2</files>
  <action>
1. Add imports at top (with graceful fallback):
   ```python
   try:
       from resilience import (
           get_timeout, with_timeout, retry_with_breaker,
           get_breaker, CircuitOpenError, DEFAULT_TIMEOUTS
       )
       RESILIENCE_AVAILABLE = True
   except ImportError:
       RESILIENCE_AVAILABLE = False
       # Define stubs
       def get_timeout(dim, cfg=None): return 60
       async def with_timeout(coro, timeout, dim=""): return await coro
       def retry_with_breaker(*a, **kw): return lambda f: f
       def get_breaker(name, **kw): return None
       class CircuitOpenError(Exception): pass
       DEFAULT_TIMEOUTS = {}
   ```

2. Replace hardcoded timeouts in validators:
   - Remove `timeout=60` from subprocess.run calls
   - Use `get_timeout(self.dimension)` for configurable timeouts
   - Wrap async validator calls with `with_timeout()`

3. Add graceful degradation to run_validators:
   ```python
   async def run_validators_graceful(
       self,
       validators: list[tuple[str, BaseValidator]]
   ) -> list[ValidationResult]:
       """Run validators with graceful degradation.

       Returns partial results even if some validators fail.
       Never hangs indefinitely.
       """
       results = []
       for name, validator in validators:
           try:
               timeout = get_timeout(validator.dimension, self.config)
               result = await with_timeout(
                   validator.validate(),
                   timeout,
                   validator.dimension
               )
               results.append(result)
           except asyncio.TimeoutError:
               results.append(ValidationResult(
                   dimension=validator.dimension,
                   tier=validator.tier,
                   passed=False,
                   message=f"Timeout after {timeout}s",
                   details={"error": "timeout"},
               ))
           except CircuitOpenError as e:
               results.append(ValidationResult(
                   dimension=validator.dimension,
                   tier=validator.tier,
                   passed=False,
                   message=f"Circuit open: {e}",
                   details={"error": "circuit_open"},
               ))
           except Exception as e:
               logger.error(f"Validator {name} failed: {e}")
               results.append(ValidationResult(
                   dimension=validator.dimension,
                   tier=validator.tier,
                   passed=False,
                   message=f"Error: {str(e)[:100]}",
                   details={"error": type(e).__name__},
               ))
       return results
   ```

4. Add circuit breaker to external calls:
   - MCP spawn_agent: `@retry_with_breaker("mcp")`
   - QuestDB push: `@retry_with_breaker("questdb")`
   - Prometheus metrics: `@retry_with_breaker("prometheus")`

5. Add timeout configuration to ValidationOrchestrator:
   ```python
   def get_validator_timeout(self, dimension: str) -> float:
       """Get timeout for dimension from config or defaults."""
       if self.config and "timeouts" in self.config:
           return self.config["timeouts"].get(dimension, DEFAULT_TIMEOUTS.get(dimension, 60))
       return DEFAULT_TIMEOUTS.get(dimension, 60)
   ```

6. Update orchestrator.py.j2 template to match.
  </action>
  <verify>python -c "from orchestrator import ValidationOrchestrator; o = ValidationOrchestrator(); print(o.get_validator_timeout('code_quality'))"</verify>
  <done>Orchestrator uses resilience module for timeout/retry/circuit breaker</done>
</task>

<task type="auto">
  <name>Task 3: Create resilience tests</name>
  <files>~/.claude/templates/validation/tests/test_resilience.py</files>
  <action>
Create comprehensive test file with 18 tests:

**Circuit breaker tests (6):**
1. `test_circuit_closed_allows_calls` - Normal state allows calls
2. `test_circuit_opens_after_fail_max` - Opens after 5 failures
3. `test_circuit_rejects_when_open` - Raises CircuitOpenError when open
4. `test_circuit_half_open_after_timeout` - Transitions to half-open
5. `test_circuit_closes_on_success` - Half-open -> closed on success
6. `test_circuit_registry_isolation` - Different breakers are independent

**Timeout tests (4):**
7. `test_timeout_completes_fast` - Fast task completes
8. `test_timeout_raises_on_slow` - Slow task raises TimeoutError
9. `test_timeout_from_config` - Config overrides defaults
10. `test_timeout_default_fallback` - Unknown dimension uses default

**Retry with breaker tests (4):**
11. `test_retry_succeeds_on_second_attempt` - Retry works
12. `test_retry_respects_max_attempts` - Stops after max
13. `test_retry_records_failures_to_breaker` - Updates circuit state
14. `test_retry_skips_when_circuit_open` - Fails fast when open

**Graceful degradation tests (4):**
15. `test_partial_results_on_timeout` - Timeout returns partial result
16. `test_partial_results_on_exception` - Exception returns partial result
17. `test_all_validators_run_despite_failures` - One failure doesn't stop others
18. `test_graceful_no_resilience_module` - Works when resilience not available (mock)

Tests should:
- Use `@pytest.mark.asyncio` for async tests
- Mock time for timeout tests (don't actually wait)
- Reset circuit breakers between tests
- Use tempfile for any disk operations
  </action>
  <verify>pytest tests/test_resilience.py -v shows 18 tests passing</verify>
  <done>18 resilience tests covering circuit breaker, timeout, and graceful degradation</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pytest tests/test_resilience.py -v` shows 18 tests passing
- [ ] Existing orchestrator tests still pass: `pytest tests/test_orchestrator.py -v`
- [ ] Circuit breaker properly opens after 5 failures (manual test)
- [ ] Timeouts are configurable per dimension
- [ ] Partial results returned on validator failure
- [ ] orchestrator.py and orchestrator.py.j2 are in sync
</verification>

<success_criteria>
- Circuit breaker with CLOSED/OPEN/HALF_OPEN states
- Configurable timeouts per dimension
- Retry with exponential backoff using tenacity
- Graceful degradation returning partial results
- 18 tests passing
- No breaking changes to existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/19-production-hardening/19-03-SUMMARY.md`
</output>
