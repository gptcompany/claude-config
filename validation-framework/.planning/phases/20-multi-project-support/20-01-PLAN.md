---
phase: 20-multi-project-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ~/.claude/templates/validation/config_loader.py
  - ~/.claude/templates/validation/orchestrator.py
  - ~/.claude/templates/validation/tests/test_config_loader.py
autonomous: true
---

<objective>
Implement config inheritance with JSON merge patch semantics.

Purpose: Allow global defaults at `~/.claude/validation/global-config.json` to cascade to project configs, enabling zero-config validation for any project.

Output: `config_loader.py` module with merge logic, orchestrator integration, 8 tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-multi-project-support/20-CONTEXT.md

@~/.claude/templates/validation/orchestrator.py
@~/.claude/validation/global-config.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config_loader.py module</name>
  <files>~/.claude/templates/validation/config_loader.py</files>
  <action>
Create new module with:

1. `GLOBAL_CONFIG_PATH = Path.home() / ".claude/validation/global-config.json"`

2. `load_global_config() -> dict`:
   - Load global config if exists, return empty dict if not
   - Handle JSON parse errors gracefully

3. `load_project_config(path: Path | None) -> dict`:
   - Load project config from path
   - If path is None, search cwd for `.claude/validation/config.json`
   - Return empty dict if not found

4. `merge_configs(global_config: dict, project_config: dict) -> dict`:
   - Implement JSON merge patch (RFC 7396) semantics
   - Project values override global at same path
   - Deep merge for nested dicts
   - Use `json-merge-patch` library if available, else implement manually:
     ```python
     def merge_configs(base, override):
         result = base.copy()
         for key, value in override.items():
             if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                 result[key] = merge_configs(result[key], value)
             else:
                 result[key] = value
         return result
     ```

5. `load_config(project_path: Path | None = None) -> dict`:
   - Compose the above: load global, load project, merge
   - Add `_config_source` field indicating merge result
  </action>
  <verify>python -c "from config_loader import load_config; print(load_config())"</verify>
  <done>config_loader.py exists with all 5 functions</done>
</task>

<task type="auto">
  <name>Task 2: Integrate with ValidationOrchestrator</name>
  <files>~/.claude/templates/validation/orchestrator.py</files>
  <action>
Modify `ValidationOrchestrator._load_config()`:

1. Import from config_loader: `from config_loader import load_config`

2. Replace current implementation:
   ```python
   def _load_config(self, path: Path | None) -> dict:
       """Load validation config with global inheritance."""
       return load_config(path)
   ```

3. Update docstring to explain inheritance behavior

4. Keep backward compatibility: if path is explicitly passed, it still works
  </action>
  <verify>cd ~/.claude/templates/validation && python -c "from orchestrator import ValidationOrchestrator; o = ValidationOrchestrator(); print(o.config.get('_config_source', 'no source'))"</verify>
  <done>Orchestrator uses config_loader for config loading</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests</name>
  <files>~/.claude/templates/validation/tests/test_config_loader.py</files>
  <action>
Create test file with 8 tests:

1. `test_load_global_config_exists` - loads global when present
2. `test_load_global_config_missing` - returns empty dict gracefully
3. `test_load_project_config_exists` - loads project config
4. `test_load_project_config_missing` - returns empty dict
5. `test_merge_configs_simple` - project overrides global
6. `test_merge_configs_deep` - nested dicts merge correctly
7. `test_merge_configs_array_override` - arrays are replaced, not merged
8. `test_load_config_integration` - full load with merge

Use tmp_path fixture for test configs. Mock GLOBAL_CONFIG_PATH for isolation.
  </action>
  <verify>cd ~/.claude/templates/validation && pytest tests/test_config_loader.py -v</verify>
  <done>8 tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pytest tests/test_config_loader.py -v` - 8 tests pass
- [ ] `pytest tests/test_orchestrator.py -v` - no regressions
- [ ] Manual test: create project with partial config, verify merge works
</verification>

<success_criteria>
- config_loader.py created with merge logic
- Orchestrator integrated with backward compatibility
- 8 tests pass
- No regressions in orchestrator tests
</success_criteria>

<output>
After completion, create `.planning/phases/20-multi-project-support/20-01-SUMMARY.md`
</output>
