---
phase: 20-multi-project-support
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - ~/.claude/templates/validation/plugins.py
  - ~/.claude/templates/validation/orchestrator.py
  - ~/.claude/templates/validation/tests/test_plugins.py
autonomous: true
---

<objective>
Implement plugin system for custom validators via uv/pip and local paths.

Purpose: Allow users to extend validation with custom validators installed via PyPI or local paths, enabling project-specific validation rules.

Output: `plugins.py` module with plugin loading, orchestrator integration, 12 tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-multi-project-support/20-CONTEXT.md

@~/.claude/templates/validation/orchestrator.py
@~/.claude/templates/validation/validators/ecc/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create plugins.py module</name>
  <files>~/.claude/templates/validation/plugins.py</files>
  <action>
Create new module with:

1. `PluginSpec` dataclass:
   ```python
   @dataclass
   class PluginSpec:
       source: str         # Original string from config
       type: str           # "pypi", "local", "git"
       name: str           # Module/package name
       path: Path | None   # For local plugins
   ```

2. `parse_plugin_spec(spec: str) -> PluginSpec`:
   - If starts with "/" or "~/" or "./" → type="local", resolve path
   - If starts with "git+" → type="git", extract URL
   - Otherwise → type="pypi", name is spec itself

3. `load_plugin(spec: PluginSpec) -> type | None`:
   - For local: add path to sys.path, import module
   - For pypi: importlib.import_module(name)
   - For git: not implemented (return None with warning)
   - Look for `Validator` class or `get_validator()` function
   - Return None if load fails (log warning, don't crash)

4. `load_plugins(specs: list[str]) -> dict[str, type]`:
   - Parse each spec, load plugin
   - Return dict of {name: ValidatorClass}
   - Skip failed loads gracefully

5. `PLUGIN_INTERFACE`:
   - Document required interface: `validate(file_path, config) -> ValidationResult`
   - Plugin validators should inherit from BaseValidator or implement same interface
  </action>
  <verify>cd ~/.claude/templates/validation && python -c "from plugins import parse_plugin_spec; print(parse_plugin_spec('my-validator'))"</verify>
  <done>plugins.py exists with loading logic</done>
</task>

<task type="auto">
  <name>Task 2: Integrate plugins with orchestrator</name>
  <files>~/.claude/templates/validation/orchestrator.py</files>
  <action>
Modify ValidationOrchestrator:

1. Import: `from plugins import load_plugins`

2. In `__init__`, after _register_validators():
   ```python
   # Load plugins from config
   plugin_specs = self.config.get("plugins", [])
   if plugin_specs:
       self._load_plugins(plugin_specs)
   ```

3. Add `_load_plugins(specs: list[str])` method:
   ```python
   def _load_plugins(self, specs: list[str]) -> None:
       """Load and register plugin validators."""
       plugins = load_plugins(specs)
       for name, validator_cls in plugins.items():
           try:
               instance = validator_cls(self.config)
               self.validators[name] = instance
               # Default to Tier 3 unless specified
               if not hasattr(instance, 'tier'):
                   instance.tier = ValidationTier.MONITOR
           except Exception as e:
               logger.warning(f"Failed to instantiate plugin {name}: {e}")
   ```

4. Update VALIDATOR_REGISTRY docstring to mention plugins
  </action>
  <verify>cd ~/.claude/templates/validation && python -c "from orchestrator import ValidationOrchestrator; o = ValidationOrchestrator(); print('plugins loaded')"</verify>
  <done>Orchestrator loads plugins from config</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests</name>
  <files>~/.claude/templates/validation/tests/test_plugins.py</files>
  <action>
Create test file with 12 tests:

**parse_plugin_spec tests (4):**
1. `test_parse_pypi_spec` - "my-validator" → type=pypi
2. `test_parse_local_absolute` - "/path/to/validator" → type=local
3. `test_parse_local_relative` - "./validators/custom" → type=local
4. `test_parse_git_spec` - "git+https://..." → type=git

**load_plugin tests (4):**
5. `test_load_local_plugin` - create temp module, load it
6. `test_load_missing_plugin` - returns None, doesn't crash
7. `test_load_invalid_plugin` - module without Validator class returns None
8. `test_load_plugin_with_get_validator` - uses get_validator() function

**Integration tests (4):**
9. `test_orchestrator_loads_plugins` - plugins appear in validators dict
10. `test_plugin_default_tier` - plugins default to Tier 3
11. `test_plugin_can_override_tier` - config can set plugin tier
12. `test_empty_plugins_list` - no error when plugins=[]

Use tmp_path to create test plugin modules.
  </action>
  <verify>cd ~/.claude/templates/validation && pytest tests/test_plugins.py -v</verify>
  <done>12 tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pytest tests/test_plugins.py -v` - 12 tests pass
- [ ] `pytest tests/test_orchestrator.py -v` - no regressions
- [ ] Create sample plugin, verify it loads via config
</verification>

<success_criteria>
- plugins.py created with parse/load logic
- Orchestrator integrates plugin loading
- 12 tests pass
- Failed plugin loads don't crash orchestrator
</success_criteria>

<output>
After completion, create `.planning/phases/20-multi-project-support/20-03-SUMMARY.md`
</output>
