---
phase: 11-ralph-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - ~/.claude/templates/validation/integrations/metrics.py
  - ~/.claude/templates/validation/integrations/sentry_context.py
  - ~/.claude/templates/validation/integrations/__init__.py
autonomous: true
---

<objective>
Create metrics and Sentry context integration modules for validation orchestrator.

Purpose: Enable observability - metrics to Grafana, debug context to Sentry
Output: Two integration modules that can be imported by orchestrator and hooks
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-ralph-integration/11-RESEARCH.md
@~/.claude/templates/validation/orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Prometheus metrics module</name>
  <files>~/.claude/templates/validation/integrations/__init__.py, ~/.claude/templates/validation/integrations/metrics.py</files>
  <action>
Create integrations directory and metrics.py that:

1. Uses prometheus_client with isolated CollectorRegistry (don't pollute global)
2. Defines metrics (from RESEARCH.md section 3):
   - validation_runs_total (Counter) - labels: tier, result, project
   - validation_duration_seconds (Histogram) - labels: tier, validator
   - validation_score (Gauge) - labels: tier, project
   - validation_blockers_count (Gauge) - labels: project, validator

3. Implements push_validation_metrics(result: ValidationReport, project: str):
   - Increments run counter
   - Records duration per validator
   - Sets current score and blocker count
   - Pushes to localhost:9091 (Pushgateway)
   - Catches connection errors - logs warning, doesn't crash

4. Graceful degradation if prometheus_client not installed:
   - Check import at module level
   - push_validation_metrics() becomes no-op if unavailable
   - Log warning once on first call

5. Add PUSHGATEWAY_URL to accept env var override (default localhost:9091)
  </action>
  <verify>cd ~/.claude/templates/validation && python3 -c "from integrations.metrics import push_validation_metrics; print('import ok')"</verify>
  <done>metrics.py importable, push_validation_metrics callable (even if prometheus_client missing)</done>
</task>

<task type="auto">
  <name>Task 2: Create Sentry context injection module</name>
  <files>~/.claude/templates/validation/integrations/sentry_context.py</files>
  <action>
Create sentry_context.py that:

1. Implements inject_validation_context(result: ValidationReport):
   - Uses sentry_sdk.set_context() for structured data
   - Uses sentry_sdk.set_tag() for searchable attributes
   - Uses sentry_sdk.add_breadcrumb() for timeline
   - Pattern from RESEARCH.md section 2

2. Implements capture_validation_error(error: Exception, context: dict):
   - Uses sentry_sdk.push_scope() for isolated context
   - Sets fingerprint for grouping
   - Captures exception with full context

3. Graceful degradation if sentry_sdk not installed or not initialized:
   - Check import at module level
   - All functions become no-op if unavailable
   - No crashes, no warnings (Sentry is optional)

4. Context to inject:
   - validation.tier, validation.passed, validation.score
   - validation.blockers (count), validation.warnings (count)
   - validation.validators_run (list)
   - validation.duration_ms
  </action>
  <verify>cd ~/.claude/templates/validation && python3 -c "from integrations.sentry_context import inject_validation_context; print('import ok')"</verify>
  <done>sentry_context.py importable, functions callable (even if sentry_sdk missing)</done>
</task>

<task type="auto">
  <name>Task 3: Wire integrations into orchestrator</name>
  <files>~/.claude/templates/validation/orchestrator.py</files>
  <action>
Update orchestrator.py to use integration modules:

1. At top, add conditional imports:
```python
try:
    from integrations.metrics import push_validation_metrics
    METRICS_AVAILABLE = True
except ImportError:
    METRICS_AVAILABLE = False
    def push_validation_metrics(*args, **kwargs): pass

try:
    from integrations.sentry_context import inject_validation_context
    SENTRY_AVAILABLE = True
except ImportError:
    SENTRY_AVAILABLE = False
    def inject_validation_context(*args, **kwargs): pass
```

2. In run_all() after each tier completes:
   - Call push_validation_metrics(tier_result, project_name)
   - Call inject_validation_context(tier_result)

3. In run_all() when blocked:
   - Add breadcrumb with blocker details

4. Log which integrations are available at startup (once, at INFO level)
  </action>
  <verify>cd ~/.claude/templates/validation && python3 orchestrator.py --tier 1 2>&1 | head -20</verify>
  <done>Orchestrator runs, metrics/sentry called (or gracefully skipped)</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python3 -c "from integrations.metrics import push_validation_metrics"` succeeds
- [ ] `python3 -c "from integrations.sentry_context import inject_validation_context"` succeeds
- [ ] `python3 orchestrator.py --tier 1` runs without import errors
- [ ] Metrics push attempted (check logs or mock Pushgateway)
- [ ] Sentry context injection attempted (check logs or mock)
</verification>

<success_criteria>
- All tasks completed
- Both integration modules importable
- Graceful degradation when dependencies missing
- Orchestrator calls integrations after each tier
- No crashes on Pushgateway/Sentry unavailability
</success_criteria>

<output>
After completion, create `.planning/phases/11-ralph-integration/11-02-SUMMARY.md`
</output>
