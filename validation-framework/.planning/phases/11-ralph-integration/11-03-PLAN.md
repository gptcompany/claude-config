---
phase: 11-ralph-integration
plan: 03
type: execute
wave: 2
depends_on: ["11-01", "11-02"]
files_modified:
  - ~/.claude/templates/validation/ralph_loop.py
  - ~/.claude/templates/validation/dashboards/validation-dashboard.json
  - ~/.claude/templates/validation/dashboards/__init__.py
autonomous: true
---

<objective>
Create Ralph Loop iterative validation and Grafana dashboard for visibility.

Purpose: Complete the integration with iterative validation loop and observability dashboard
Output: Working ralph_loop.py CLI and Grafana dashboard JSON template
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-ralph-integration/11-RESEARCH.md
@~/.claude/templates/validation/orchestrator.py
@.planning/phases/11-ralph-integration/11-01-SUMMARY.md
@.planning/phases/11-ralph-integration/11-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Ralph Loop state machine</name>
  <files>~/.claude/templates/validation/ralph_loop.py</files>
  <action>
Create ralph_loop.py implementing the loop from RESEARCH.md section 4:

1. Define LoopState enum: IDLE, VALIDATING, BLOCKED, FIX_REQUESTED, COMPLETE

2. Define RalphLoopConfig dataclass:
   - max_iterations: int = 5
   - min_score_threshold: float = 70.0
   - tier1_timeout_seconds: float = 30.0
   - tier2_timeout_seconds: float = 120.0

3. Define LoopResult dataclass:
   - state: LoopState
   - iteration: int
   - score: float | None
   - blockers: list[str]
   - message: str
   - history: list[dict]

4. Implement RalphLoop class:
   - __init__(orchestrator, config)
   - async run(changed_files: list[str]) -> LoopResult
   - State machine: IDLE -> VALIDATING -> (BLOCKED | COMPLETE)
   - On Tier 1 failure: set BLOCKED, return immediately
   - On success: run Tier 2+3 in parallel, calculate score
   - If score < threshold and iterations remain: continue
   - Track history of each iteration

5. Call push_validation_metrics() and inject_validation_context() after each tier

6. CLI interface:
   - --files: comma-separated or read from stdin
   - --project: project name (or auto-detect from git)
   - --config: optional config file path
   - --json: output as JSON
  </action>
  <verify>cd ~/.claude/templates/validation && python3 ralph_loop.py --help</verify>
  <done>ralph_loop.py runs, shows help, accepts --files argument</done>
</task>

<task type="auto">
  <name>Task 2: Create Grafana dashboard template</name>
  <files>~/.claude/templates/validation/dashboards/__init__.py, ~/.claude/templates/validation/dashboards/validation-dashboard.json</files>
  <action>
Create dashboards directory and validation-dashboard.json:

1. Dashboard metadata:
   - uid: "validation-orchestrator"
   - title: "Validation Orchestrator"
   - tags: ["validation", "ci"]

2. Panels (from RESEARCH.md section 3):
   - Row 1: Overview
     - Validation Pass Rate (stat, gauge) - rate(validation_runs_total{result='pass'}[1h])
     - Current Score (stat, gauge) - validation_score
     - Active Blockers (stat, red if >0) - sum(validation_blockers_count)

   - Row 2: Trends
     - Validation Runs (timeseries) - rate(validation_runs_total[5m])
     - Duration Heatmap (heatmap) - validation_duration_seconds_bucket

   - Row 3: Breakdown
     - Blockers by Validator (timeseries, stacked) - validation_blockers_count by validator
     - Tier Results (bar gauge) - validation_runs_total by tier

3. Variables:
   - project: label_values(validation_runs_total, project)
   - tier: 1, 2, 3

4. Time range: Last 6 hours default

5. Use Prometheus datasource (variable: ${DS_PROMETHEUS})
  </action>
  <verify>cd ~/.claude/templates/validation && python3 -c "import json; d = json.load(open('dashboards/validation-dashboard.json')); print('panels:', len(d.get('panels', [])))"</verify>
  <done>Dashboard JSON valid, contains expected panels</done>
</task>

<task type="auto">
  <name>Task 3: Add git post-commit hook template</name>
  <files>~/.claude/templates/validation/hooks/post-commit.sh</files>
  <action>
Create post-commit.sh template (from RESEARCH.md section 5):

```bash
#!/bin/bash
# Git post-commit hook for Ralph Loop validation
# Install: cp ~/.claude/templates/validation/hooks/post-commit.sh .git/hooks/post-commit && chmod +x .git/hooks/post-commit

set -e

# Get changed files in this commit
CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r HEAD | tr '\n' ',')

# Get project name
PROJECT=$(basename "$(git rev-parse --show-toplevel)")

# Run Ralph loop (async - don't block commit)
python3 ~/.claude/templates/validation/ralph_loop.py \
    --files "$CHANGED_FILES" \
    --project "$PROJECT" \
    --json > /tmp/ralph_result.json 2>&1 &

# Optional: Show quick status
echo "Ralph validation triggered for $PROJECT"
```

Make it non-blocking (background process) so commits aren't delayed.
  </action>
  <verify>bash -n ~/.claude/templates/validation/hooks/post-commit.sh && echo "syntax ok"</verify>
  <done>post-commit.sh valid bash, non-blocking execution</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python3 ralph_loop.py --help` shows usage
- [ ] `python3 ralph_loop.py --files test.py --project test --json` runs validation loop
- [ ] Dashboard JSON is valid (python json.load succeeds)
- [ ] Dashboard has at least 6 panels
- [ ] post-commit.sh passes bash -n syntax check
- [ ] Integration with metrics/sentry from Plan 11-02 works
</verification>

<success_criteria>
- All tasks completed
- Ralph loop runs iteratively with state machine
- Tier 1 blocks, Tier 2+3 run in parallel
- Metrics pushed after each tier
- Dashboard ready for Grafana import
- Git hook template ready for installation
</success_criteria>

<output>
After completion, create `.planning/phases/11-ralph-integration/11-03-SUMMARY.md`
</output>
