---
phase: 11-ralph-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ~/.claude/templates/validation/hooks/post_tool_hook.py
  - ~/.claude/templates/validation/hooks/__init__.py
autonomous: true
---

<objective>
Create PostToolUse hook that integrates validation orchestrator into Claude Code workflow with Tier 1 blocking.

Purpose: Enable automatic validation on every Write/Edit operation, blocking on Tier 1 failures
Output: Working PostToolUse hook that reads stdin, runs Tier 1 validation, returns block/approve decision
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-ralph-integration/11-RESEARCH.md
@~/.claude/templates/validation/orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PostToolUse hook infrastructure</name>
  <files>~/.claude/templates/validation/hooks/__init__.py, ~/.claude/templates/validation/hooks/post_tool_hook.py</files>
  <action>
Create hooks directory and PostToolUse hook that:
1. Reads JSON from stdin (tool_name, tool_input, session_id)
2. Only processes Write/Edit tools (approve others immediately)
3. Extracts file_path from tool_input
4. Imports and runs ValidationOrchestrator with tier=1 only
5. Returns JSON to stdout: {"decision": "approve"} or {"decision": "block", "reason": "..."}
6. Has 30s timeout to avoid blocking workflow
7. Catches all exceptions - returns approve on error (fail-open)

Use patterns from RESEARCH.md section 1 (Hook Integration Pattern).
Do NOT import sentry_sdk or prometheus_client - those are separate plans.
  </action>
  <verify>python3 -c "from hooks.post_tool_hook import main; print('import ok')"</verify>
  <done>Hook module importable, reads stdin, returns valid JSON response</done>
</task>

<task type="auto">
  <name>Task 2: Add file-specific Tier 1 validation to orchestrator</name>
  <files>~/.claude/templates/validation/orchestrator.py</files>
  <action>
Add method to ValidationOrchestrator:

```python
async def validate_file(self, file_path: str, tier: int = 1) -> ValidationResult:
    """Quick validation for a single file. Used by hooks."""
    # Only run validators relevant to this file type
    # For Python files: code_quality, type_safety, security
    # For other files: skip or minimal checks
    # Returns single aggregated result with has_blockers property
```

Add `has_blockers` property to ValidationResult if not present.
Keep backward compatible - run_all() still works unchanged.
  </action>
  <verify>cd ~/.claude/templates/validation && python3 -c "from orchestrator import ValidationOrchestrator; o = ValidationOrchestrator(); print('validate_file method:', hasattr(o, 'validate_file'))"</verify>
  <done>validate_file() method exists and returns result with has_blockers</done>
</task>

<task type="auto">
  <name>Task 3: Create hook installation helper</name>
  <files>~/.claude/templates/validation/hooks/install.py</files>
  <action>
Create install.py that:
1. Reads existing ~/.claude/settings.json (or creates it)
2. Adds PostToolUse hook entry for Write|Edit tools
3. Points to post_tool_hook.py with full path
4. Backs up existing settings before modifying
5. Prints confirmation message

Hook config to add:
```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": {"tool_name": "Write|Edit"},
        "hooks": [{"type": "command", "command": "python3 ~/.claude/templates/validation/hooks/post_tool_hook.py"}]
      }
    ]
  }
}
```

Note: Merge with existing hooks, don't replace.
  </action>
  <verify>python3 ~/.claude/templates/validation/hooks/install.py --dry-run</verify>
  <done>install.py runs without error, shows what it would add to settings.json</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python3 -c "from hooks.post_tool_hook import main"` succeeds
- [ ] `echo '{"tool_name": "Read", "tool_input": {}}' | python3 hooks/post_tool_hook.py` returns `{"decision": "approve"}`
- [ ] `echo '{"tool_name": "Write", "tool_input": {"file_path": "test.py"}}' | python3 hooks/post_tool_hook.py` runs validation
- [ ] validate_file() method exists on orchestrator
- [ ] install.py --dry-run shows correct hook config
</verification>

<success_criteria>
- All tasks completed
- Hook reads stdin and returns valid JSON
- Tier 1 validation runs for Write/Edit tools
- Other tools get immediate approve
- 30s timeout prevents blocking
- Fail-open on errors (approve, don't crash)
</success_criteria>

<output>
After completion, create `.planning/phases/11-ralph-integration/11-01-SUMMARY.md`
</output>
