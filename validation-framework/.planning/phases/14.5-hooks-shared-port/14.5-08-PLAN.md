---
phase: 14.5-hooks-shared-port
plan: 08
type: execute
wave: 5
depends_on: ["14.5-07"]
files_modified:
  - ~/.claude/scripts/lib/hook-debugger.js
  - ~/.claude/scripts/lib/hook-validator.js
  - ~/.claude/scripts/hooks/debug/hook-tracer.js
  - ~/.claude/scripts/hooks/debug/hook-health.js
  - ~/.claude/scripts/test-all-hooks.js
autonomous: true
---

<objective>
Create comprehensive hook debugging and validation system.

Purpose: 95% confidence in hook functionality with full observability
Output: Debug system + validation suite + health monitoring
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/14.5-hooks-shared-port/14.5-RESEARCH.md

# Critical requirements:
# 1. Track if hooks are actually called
# 2. Capture hook input/output
# 3. Measure hook effectiveness
# 4. Validate expected vs actual results
# 5. 95% confidence via comprehensive tests
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hook-debugger.js library with QuestDB export</name>
  <files>~/.claude/scripts/lib/hook-debugger.js</files>
  <action>
1. Create debug library with LOCAL logging:
   - `HOOK_DEBUG_DIR` = ~/.claude/debug/hooks/
   - `enableDebug(hookName)` - enable debug for specific hook
   - `disableDebug(hookName)` - disable
   - `logInvocation(hookName, input, timestamp)` - log when called
   - `logOutput(hookName, output, duration)` - log result
   - `getInvocationLog(hookName, last=100)` - get recent invocations
   - `getHookStats(hookName)` - {calls, errors, avgDuration, lastCall}
   - `clearLogs(hookName)` - clear logs

2. Log format (JSON Lines):
   ```json
   {"ts":"ISO","hook":"name","event":"invoke|output|error","data":{}}
   ```

3. Automatic log rotation (max 1000 entries per hook)

4. QuestDB EXPORT for Grafana visibility:
   - Use metrics.js `exportToQuestDB()` function
   - Table: `claude_hook_invocations`
   - Fields: hook, event, duration_ms, success, error_type
   - Tags: project, session_id
   - Export async (non-blocking) on each invocation

5. Aggregated metrics export (every 100 invocations):
   - Table: `claude_hook_stats`
   - Fields: calls, errors, avg_duration_ms, p95_duration_ms
   - Enables Grafana dashboards for hook health monitoring
  </action>
  <verify>node -e "const d = require('$HOME/.claude/scripts/lib/hook-debugger'); d.logInvocation('test', {})"</verify>
  <done>hook-debugger.js provides full invocation tracking + QuestDB export</done>
</task>

<task type="auto">
  <name>Task 2: Create hook-validator.js library</name>
  <files>~/.claude/scripts/lib/hook-validator.js</files>
  <action>
1. Create validation library:
   - `validateHookConfig(hooksJson)` - validate hooks.json structure
   - `validateHookScript(scriptPath)` - check script exists, executable
   - `validateHookOutput(output, expectedSchema)` - validate output format
   - `testHookExecution(hookName, testInput)` - run hook with test input
   - `compareExpectedActual(expected, actual)` - diff results
   - `generateValidationReport(results)` - summary report

2. Validation checks:
   - Script file exists
   - Script is executable
   - Script returns valid JSON
   - Script exits with code 0
   - Output matches expected schema
   - No stderr errors (unless intentional)

3. Expected schemas per hook event:
   - PreToolUse: {decision?, reason?, message?}
   - PostToolUse: {systemMessage?}
   - UserPromptSubmit: {additionalContext?}
   - Stop: {systemMessage?}
  </action>
  <verify>node -e "const v = require('$HOME/.claude/scripts/lib/hook-validator'); console.log(v.validateHookConfig)"</verify>
  <done>hook-validator.js validates hook configuration and output</done>
</task>

<task type="auto">
  <name>Task 3: Create hook-tracer.js (debug hook)</name>
  <files>~/.claude/scripts/hooks/debug/hook-tracer.js</files>
  <action>
1. Create directory: `mkdir -p ~/.claude/scripts/hooks/debug`
2. Hook tracer runs on ALL events (meta-hook):
   - Intercepts every hook invocation
   - Logs to ~/.claude/debug/hooks/trace.jsonl
   - Records: timestamp, event, hook, input, output, duration, success

3. Enable via environment: CLAUDE_HOOK_TRACE=1
4. Output format:
   ```json
   {
     "ts": "2026-01-24T12:00:00Z",
     "event": "PreToolUse",
     "hook": "git-safety-check",
     "input": {"tool_name": "Bash"},
     "output": {},
     "duration_ms": 12,
     "success": true
   }
   ```
5. Don't affect hook execution (async logging)
  </action>
  <verify>CLAUDE_HOOK_TRACE=1 echo '{}' | node ~/.claude/scripts/hooks/debug/hook-tracer.js</verify>
  <done>hook-tracer.js provides full invocation tracing</done>
</task>

<task type="auto">
  <name>Task 4: Create hook-health.js (health monitoring with QuestDB)</name>
  <files>~/.claude/scripts/hooks/debug/hook-health.js</files>
  <action>
1. Health monitoring system:
   - Periodically check all hooks
   - Report status: healthy/degraded/failing
   - Track error rates
   - Detect stuck hooks

2. Health checks:
   - Script exists and executable
   - Returns within timeout (5s)
   - Output is valid JSON
   - No repeated errors

3. LOCAL status file: ~/.claude/debug/hooks/health.json
   ```json
   {
     "lastCheck": "ISO",
     "hooks": {
       "git-safety-check": {"status": "healthy", "lastSuccess": "ISO", "errorRate": 0},
       "session-analyzer": {"status": "degraded", "lastSuccess": "ISO", "errorRate": 0.15}
     }
   }
   ```

4. QuestDB EXPORT for Grafana dashboards:
   - Table: `claude_hook_health`
   - Fields: status (0=healthy, 1=degraded, 2=failing), error_rate, last_success_age_s
   - Tags: hook, project
   - Export on each health check run
   - Enables Grafana alerts on degraded hooks

5. CLI command: `node hook-health.js --check` runs full health check
6. CLI command: `node hook-health.js --export` forces QuestDB export
  </action>
  <verify>node ~/.claude/scripts/hooks/debug/hook-health.js --check</verify>
  <done>hook-health.js monitors health + exports to QuestDB</done>
</task>

<task type="auto">
  <name>Task 5: Create test-all-hooks.js (comprehensive test suite)</name>
  <files>~/.claude/scripts/test-all-hooks.js</files>
  <action>
1. Master test runner that validates ALL hooks:
   - Load hooks.json
   - For each hook:
     - Validate script exists
     - Run with test input
     - Verify output format
     - Check expected behavior

2. Test categories:
   - EXISTENCE: Script file exists, is executable
   - SYNTAX: Returns valid JSON, exits 0
   - BEHAVIOR: Produces expected output for test cases
   - INTEGRATION: Works with other hooks in chain

3. Test cases per hook type:
   - Safety hooks: block dangerous, allow safe
   - Intelligence hooks: produce context, save state
   - Quality hooks: detect patterns, suggest fixes
   - Productivity hooks: format, checkpoint
   - Metrics hooks: track data, persist
   - Coordination hooks: claim/release works

4. Output:
   ```
   Hook Validation Report
   ======================
   Total: 40 hooks
   Passed: 38 (95%)
   Failed: 2 (5%)

   FAILED:
   - git-safety-check: Output schema mismatch
   - session-analyzer: Timeout after 5000ms
   ```

5. Exit code: 0 if ≥95% pass, 1 otherwise
  </action>
  <verify>node ~/.claude/scripts/test-all-hooks.js --dry-run</verify>
  <done>test-all-hooks.js validates all hooks with 95% confidence target</done>
</task>

<task type="auto">
  <name>Task 6: Create effectiveness validation tests</name>
  <files>~/.claude/scripts/hooks/debug/effectiveness.test.js</files>
  <action>
1. Test that hooks actually affect behavior:

   a. Safety hooks effectiveness:
      - Send dangerous command → verify blocked
      - Send safe command → verify allowed
      - Check block reason is meaningful

   b. Intelligence hooks effectiveness:
      - Start session → verify context injected
      - End session → verify insights saved
      - Check SSOT file created correctly

   c. Quality hooks effectiveness:
      - Write code → verify format triggered
      - Create PR → verify readiness checked
      - Check files actually modified

   d. Metrics hooks effectiveness:
      - Track event → verify metric saved
      - Check metric file contains expected data
      - Verify aggregation works

2. Each test:
   - Setup: prepare test environment
   - Action: trigger hook
   - Verify: check actual result matches expected
   - Cleanup: restore state

3. Minimum 50 effectiveness tests
  </action>
  <verify>node --test ~/.claude/scripts/hooks/debug/effectiveness.test.js</verify>
  <done>effectiveness.test.js validates hooks actually work</done>
</task>

<task type="auto">
  <name>Task 7: Create diagnostic CLI commands</name>
  <files>~/.claude/scripts/hooks/debug/hooks-cli.js</files>
  <action>
1. Create CLI for hook diagnostics:

   ```bash
   # Show all hooks and their status
   node hooks-cli.js status

   # Test specific hook
   node hooks-cli.js test git-safety-check

   # Show recent invocations
   node hooks-cli.js log git-safety-check --last 10

   # Run full validation
   node hooks-cli.js validate

   # Show hook statistics
   node hooks-cli.js stats

   # Debug mode for hook
   node hooks-cli.js debug git-safety-check --enable
   ```

2. Output is human-readable with colors
3. JSON output with --json flag
4. Integrates with hook-debugger and hook-validator
  </action>
  <verify>node ~/.claude/scripts/hooks/debug/hooks-cli.js status</verify>
  <done>hooks-cli.js provides diagnostic commands</done>
</task>

<task type="auto">
  <name>Task 8: Integrate debug hooks into hooks.json</name>
  <files>~/.claude/hooks/hooks.json</files>
  <action>
1. Add debug hooks to hooks.json (disabled by default):
   ```json
   {
     "hooks": {
       "PreToolUse": [
         {
           "command": "node ~/.claude/scripts/hooks/debug/hook-tracer.js",
           "event": "*",
           "enabled": false,
           "description": "Debug: Trace all hook invocations"
         }
       ]
     }
   }
   ```

2. Add `enabled` field to all hooks (default true)
3. Add `description` field to all hooks
4. Add `timeout` field (default 5000ms)
5. Create hooks.schema.json for validation
  </action>
  <verify>jq '.hooks | keys' ~/.claude/hooks/hooks.json</verify>
  <done>hooks.json includes debug hooks and metadata</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] hook-debugger.js tracks all invocations
- [ ] hook-validator.js validates config and output
- [ ] hook-tracer.js traces all events
- [ ] hook-health.js monitors health
- [ ] test-all-hooks.js achieves ≥95% pass rate
- [ ] effectiveness.test.js validates actual behavior
- [ ] hooks-cli.js provides diagnostics
- [ ] hooks.json updated with debug support
- [ ] 50+ effectiveness tests pass
</verification>

<success_criteria>
- Complete observability: know when/how hooks are called
- Full validation: 95% confidence in hook functionality
- Easy debugging: CLI commands for diagnostics
- Health monitoring: detect failing hooks proactively
- 50+ effectiveness tests proving hooks work
</success_criteria>

<output>
After completion, create `.planning/phases/14.5-hooks-shared-port/14.5-08-SUMMARY.md`
</output>
