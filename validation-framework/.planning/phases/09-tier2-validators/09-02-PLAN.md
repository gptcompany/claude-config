---
phase: 09-tier2-validators
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - ~/.claude/templates/validation/validators/oss_reuse/validator.py
  - ~/.claude/templates/validation/validators/oss_reuse/patterns.py
  - ~/.claude/templates/validation/orchestrator.py.j2
autonomous: true
domain: validation
---

<objective>
Create the oss_reuse validator that detects reimplemented patterns and suggests OSS packages, with PyPI API validation to ensure suggestions are valid.

Purpose: Help developers avoid reinventing the wheel by suggesting well-maintained OSS packages for common patterns.
Output: Working oss_reuse validator with pattern detection and PyPI validation, wired into orchestrator.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-tier2-validators/09-RESEARCH.md
@.planning/phases/09-tier2-validators/09-CONTEXT.md
@~/.claude/templates/validation/orchestrator.py.j2
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create oss_reuse validator with pattern detection</name>
  <files>~/.claude/templates/validation/validators/oss_reuse/validator.py, ~/.claude/templates/validation/validators/oss_reuse/patterns.py, ~/.claude/templates/validation/validators/oss_reuse/__init__.py</files>
  <action>
Create directory `~/.claude/templates/validation/validators/oss_reuse/` and implement:

**patterns.py** - Pattern definitions:
```python
"""OSS pattern definitions for common reimplementations."""

OSS_PATTERNS = {
    "date_parsing": {
        "patterns": [r"strptime\s*\(", r"parse.*date", r"datetime\.strptime"],
        "suggestion": "python-dateutil",
        "reason": "Handles edge cases like timezones, relative dates",
        "confidence": "medium",  # strptime is sometimes fine
    },
    "http_client": {
        "patterns": [r"urllib\.request", r"http\.client\.HTTP", r"socket.*connect"],
        "suggestion": "requests or httpx",
        "reason": "Better API, connection pooling, retries",
        "confidence": "high",
    },
    "json_validation": {
        "patterns": [r"validate.*schema", r"isinstance.*dict.*for", r"if\s+['\"]type['\"]\s+in"],
        "suggestion": "jsonschema or pydantic",
        "reason": "Battle-tested validation with error messages",
        "confidence": "medium",
    },
    "yaml_unsafe": {
        "patterns": [r"yaml\.load\s*\([^,)]+\)", r"yaml\.load\(\s*[^,]+\s*\)"],
        "suggestion": "Use yaml.safe_load() instead",
        "reason": "yaml.load() allows arbitrary code execution",
        "confidence": "high",
    },
    "cli_args_manual": {
        "patterns": [r"sys\.argv\[(?!0\])", r"for\s+arg\s+in\s+sys\.argv"],
        "suggestion": "click or typer",
        "reason": "Automatic help, type conversion, validation",
        "confidence": "high",
    },
    "retry_manual": {
        "patterns": [r"while.*retry", r"for.*attempt.*in.*range", r"except.*sleep.*continue"],
        "suggestion": "tenacity",
        "reason": "Configurable backoff, jitter, retry conditions",
        "confidence": "medium",
    },
    "cache_dict": {
        "patterns": [r"cache\s*=\s*\{\}", r"_cache\s*=\s*\{\}", r"if\s+\w+\s+not\s+in\s+cache"],
        "suggestion": "functools.lru_cache or cachetools",
        "reason": "LRU eviction, TTL, thread safety",
        "confidence": "medium",
    },
    "env_manual": {
        "patterns": [r"os\.environ\.get\s*\(\s*['\"][A-Z_]+['\"]\s*\)", r"os\.getenv\s*\(\s*['\"][A-Z_]+['\"]\s*\)"],
        "suggestion": "pydantic-settings or python-dotenv",
        "reason": "Typed settings, validation, .env file support",
        "confidence": "low",  # os.environ.get is often fine
    },
    "subprocess_shell": {
        "patterns": [r"subprocess\..*shell\s*=\s*True", r"os\.system\s*\("],
        "suggestion": "subprocess.run with shell=False",
        "reason": "Security: shell injection risk",
        "confidence": "high",
    },
    "path_join": {
        "patterns": [r"os\.path\.join\s*\("],
        "suggestion": "pathlib.Path (stdlib)",
        "reason": "Object-oriented API, cross-platform",
        "confidence": "low",  # os.path.join is fine, just older style
    },
}
```

**validator.py** - Main validator:
```python
"""OSS Reuse Validator - Suggests packages for reimplemented patterns."""

import ast
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Any

# Import patterns
from .patterns import OSS_PATTERNS

# Import base from orchestrator (use relative when possible)
try:
    from ..orchestrator import BaseValidator, ValidationResult, ValidationTier
except ImportError:
    # Standalone testing - define minimal types
    from dataclasses import dataclass, field
    from enum import Enum
    class ValidationTier(Enum):
        BLOCKER = 1
        WARNING = 2
        MONITOR = 3
    @dataclass
    class ValidationResult:
        dimension: str
        tier: ValidationTier
        passed: bool
        message: str
        details: dict = None
        fix_suggestion: str = None
        agent: str = None
        duration_ms: int = 0
    class BaseValidator:
        dimension = "unknown"
        tier = ValidationTier.MONITOR
        agent = None


@dataclass
class PatternMatch:
    """A detected pattern match."""
    pattern_name: str
    file_path: str
    line_number: int
    match_text: str
    suggestion: str
    reason: str
    confidence: str


class OSSReuseValidator(BaseValidator):
    """Tier 2: OSS reuse suggestions for reimplemented patterns."""

    dimension = "oss_reuse"
    tier = ValidationTier.WARNING
    agent = None  # No auto-fix agent for this

    def __init__(self, config: dict = None):
        self.config = config or {}
        self.min_confidence = self.config.get("min_confidence", "medium")
        # Confidence levels: high > medium > low
        self.confidence_order = {"high": 3, "medium": 2, "low": 1}

    async def validate(self) -> ValidationResult:
        """Scan Python files for reimplemented patterns."""
        from datetime import datetime
        start = datetime.now()

        matches = []
        files_scanned = 0

        # Scan Python files in current directory
        for py_file in Path(".").rglob("*.py"):
            # Skip common non-source directories
            if any(part.startswith(".") or part in ("venv", "env", "__pycache__", "node_modules", ".git")
                   for part in py_file.parts):
                continue

            try:
                content = py_file.read_text()
                files_scanned += 1
                file_matches = self._scan_file(py_file, content)
                matches.extend(file_matches)
            except Exception:
                continue

        # Filter by confidence threshold
        min_level = self.confidence_order.get(self.min_confidence, 2)
        filtered_matches = [
            m for m in matches
            if self.confidence_order.get(m.confidence, 0) >= min_level
        ]

        passed = len(filtered_matches) == 0

        # Build suggestion message
        suggestions = []
        for m in filtered_matches[:5]:  # Top 5 suggestions
            suggestions.append(f"{m.file_path}:{m.line_number} - {m.pattern_name}: use {m.suggestion}")

        duration_ms = int((datetime.now() - start).total_seconds() * 1000)

        return ValidationResult(
            dimension=self.dimension,
            tier=self.tier,
            passed=passed,
            message=f"{len(filtered_matches)} OSS suggestions" if not passed else "No reimplementations detected",
            details={
                "files_scanned": files_scanned,
                "total_matches": len(matches),
                "filtered_matches": len(filtered_matches),
                "suggestions": [vars(m) for m in filtered_matches[:10]],
            },
            fix_suggestion="\n".join(suggestions) if suggestions else None,
            duration_ms=duration_ms,
        )

    def _scan_file(self, file_path: Path, content: str) -> list[PatternMatch]:
        """Scan a single file for patterns."""
        matches = []
        lines = content.split("\n")

        for pattern_name, pattern_config in OSS_PATTERNS.items():
            for pattern in pattern_config["patterns"]:
                try:
                    regex = re.compile(pattern)
                    for i, line in enumerate(lines, 1):
                        if regex.search(line):
                            # Check if already using the suggested package
                            if not self._already_using_suggestion(content, pattern_config["suggestion"]):
                                matches.append(PatternMatch(
                                    pattern_name=pattern_name,
                                    file_path=str(file_path),
                                    line_number=i,
                                    match_text=line.strip()[:80],
                                    suggestion=pattern_config["suggestion"],
                                    reason=pattern_config["reason"],
                                    confidence=pattern_config["confidence"],
                                ))
                except re.error:
                    continue

        return matches

    def _already_using_suggestion(self, content: str, suggestion: str) -> bool:
        """Check if file already imports the suggested package."""
        # Handle "X or Y" suggestions
        packages = suggestion.replace(" or ", ",").replace(" ", "").split(",")
        for pkg in packages:
            pkg_base = pkg.split(".")[0].replace("-", "_")
            if re.search(rf"^\s*(import|from)\s+{pkg_base}", content, re.MULTILINE):
                return True
        return False
```

**__init__.py**:
```python
from .validator import OSSReuseValidator
from .patterns import OSS_PATTERNS

__all__ = ["OSSReuseValidator", "OSS_PATTERNS"]
```

**Key implementation notes:**
- Start with 10 high-value patterns (from CONTEXT.md)
- Filter by confidence level (config.min_confidence)
- Skip if already using suggested package (avoid false positives)
- Return top 5 suggestions in fix_suggestion
- No PyPI validation for v1 (add in future iteration to avoid API rate limits)
  </action>
  <verify>
```bash
cd ~/.claude/templates/validation/validators/oss_reuse
python3 -c "from validator import OSSReuseValidator; v = OSSReuseValidator(); print('OK')"
python3 -c "from patterns import OSS_PATTERNS; print(f'{len(OSS_PATTERNS)} patterns loaded')"
```
  </verify>
  <done>OSSReuseValidator exists with pattern detection, handles edge cases (already using package, confidence filtering)</done>
</task>

<task type="auto">
  <name>Task 2: Update orchestrator with oss_reuse implementation</name>
  <files>~/.claude/templates/validation/orchestrator.py.j2</files>
  <action>
Update orchestrator.py.j2 to use the real OSSReuseValidator:

1. Add import at top (with fallback):
```python
try:
    from validators.oss_reuse.validator import OSSReuseValidator as OSSReuseValidatorImpl
except ImportError:
    OSSReuseValidatorImpl = None
```

2. Update VALIDATOR_REGISTRY:
```python
"oss_reuse": OSSReuseValidatorImpl if OSSReuseValidatorImpl else BaseValidator,
```

3. Ensure the `_register_validators()` method handles None class gracefully (skip if validator not available).

**Note:** This task modifies the same file as Plan 09-01 Task 2. If both plans run in parallel, they should make additive changes. The imports and registry entries are separate and can be merged.

If running sequentially after 09-01:
- Verify the fallback import pattern is already in place
- Add oss_reuse import alongside design_principles import
- Add oss_reuse to registry alongside design_principles

If running in parallel:
- Make minimal changes, expect merge on completion
  </action>
  <verify>
```bash
cd ~/.claude/templates/validation
python3 -c "
from orchestrator import ValidationOrchestrator
o = ValidationOrchestrator()
print(f'Registered validators: {list(o.validators.keys())}')
print('oss_reuse' in o.VALIDATOR_REGISTRY and 'OK' or 'FALLBACK')
"
```
  </verify>
  <done>Orchestrator uses real OSSReuseValidator, graceful fallback when not installed</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `validators/oss_reuse/validator.py` exists with OSSReuseValidator
- [ ] `validators/oss_reuse/patterns.py` defines 10+ detection patterns
- [ ] Validator detects patterns and suggests packages
- [ ] Validator skips files already using suggested package
- [ ] Orchestrator imports real validator (or graceful fallback)
- [ ] All files pass basic import test
</verification>

<success_criteria>

- All tasks completed
- OSSReuseValidator detects reimplemented patterns
- Pattern confidence filtering works
- Already-using-package detection prevents false positives
- Orchestrator uses real implementation
- No regressions to existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/09-tier2-validators/09-02-SUMMARY.md`
</output>
