---
phase: 09-tier2-validators
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ~/.claude/templates/validation/validators/design_principles/validator.py
  - ~/.claude/templates/validation/orchestrator.py.j2
  - /media/sam/1TB/claude-hooks-shared/hooks/quality/post-commit-quality.py
autonomous: true
domain: validation
---

<objective>
Create the design_principles validator using radon for cyclomatic complexity and AST for nesting depth/parameter count, then integrate into orchestrator and post-commit hook.

Purpose: Enable automatic detection of KISS/YAGNI/DRY violations during validation runs and post-commit checks.
Output: Working design_principles validator with radon-based complexity analysis, wired into orchestrator and post-commit hook.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-tier2-validators/09-RESEARCH.md
@.planning/phases/09-tier2-validators/09-CONTEXT.md
@~/.claude/templates/validation/orchestrator.py.j2
@/media/sam/1TB/claude-hooks-shared/hooks/quality/post-commit-quality.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create design_principles validator with radon + AST</name>
  <files>~/.claude/templates/validation/validators/design_principles/validator.py, ~/.claude/templates/validation/validators/design_principles/__init__.py</files>
  <action>
Create directory `~/.claude/templates/validation/validators/design_principles/` and implement:

**validator.py** with:
1. `DesignPrinciplesValidator` class extending BaseValidator (from orchestrator.py.j2 pattern)
2. Uses radon programmatic API (`from radon.complexity import cc_visit`, `from radon.metrics import mi_visit`)
3. Custom AST NodeVisitor for:
   - Nesting depth analysis (if/for/while/with/try statements)
   - Parameter count per function
4. Config-driven thresholds from `dimensions.design_principles`:
   - `max_complexity` (default 10 for grade B cutoff)
   - `max_nesting` (default 4)
   - `max_params` (default 5)

**Key implementation details:**
- Use `radon cc -j` style output parsing if shelling out, OR use programmatic API directly
- For nesting: Track depth during AST traversal, report max per function
- Output violations in ValidationResult.details with file:line references
- Set `fix_suggestion` to describe what should be simplified
- Set `agent="code-simplifier"` when violations found

**Patterns to follow from RESEARCH.md:**
```python
from radon.complexity import cc_visit
from radon.metrics import mi_visit

# Cyclomatic complexity
results = cc_visit(code)
for block in results:
    if block.complexity > threshold:
        # Report violation
```

**Do NOT:**
- Hardcode thresholds - read from config
- Block on warnings (this is Tier 2)
- Shell out for radon when programmatic API works

**__init__.py**: Export DesignPrinciplesValidator
  </action>
  <verify>
```bash
cd ~/.claude/templates/validation/validators/design_principles
python3 -c "from validator import DesignPrinciplesValidator; v = DesignPrinciplesValidator(); print('OK')"
```
  </verify>
  <done>DesignPrinciplesValidator class exists with radon + AST analysis, imports successfully</done>
</task>

<task type="auto">
  <name>Task 2: Update orchestrator stub with real implementation</name>
  <files>~/.claude/templates/validation/orchestrator.py.j2</files>
  <action>
Replace the stub `DesignPrinciplesValidator` in orchestrator.py.j2 with:

1. Import from the new validator module:
```python
# At top of file, in imports section:
from validators.design_principles.validator import DesignPrinciplesValidator as DesignPrinciplesValidatorImpl
```

2. Update VALIDATOR_REGISTRY to use the real implementation:
```python
"design_principles": DesignPrinciplesValidatorImpl,
```

3. Remove the old stub class (the inline DesignPrinciplesValidator that just checks file sizes)

**Important:** The orchestrator.py.j2 is a Jinja2 template. Ensure the import works both:
- When rendered with Jinja2 ({{ project_name }} vars)
- When run directly for testing

Use conditional import pattern if needed:
```python
try:
    from validators.design_principles.validator import DesignPrinciplesValidator
except ImportError:
    # Fallback to stub when validators not installed
    class DesignPrinciplesValidator(BaseValidator):
        dimension = "design_principles"
        tier = ValidationTier.WARNING
        async def validate(self) -> ValidationResult:
            return ValidationResult(dimension=self.dimension, tier=self.tier, passed=True, message="Validators not installed")
```
  </action>
  <verify>
```bash
cd ~/.claude/templates/validation
python3 -c "from orchestrator import ValidationOrchestrator; print('Orchestrator imports OK')"
```
  </verify>
  <done>Orchestrator imports real DesignPrinciplesValidator, falls back gracefully if not installed</done>
</task>

<task type="auto">
  <name>Task 3: Extend post-commit-quality.py with radon metrics</name>
  <files>/media/sam/1TB/claude-hooks-shared/hooks/quality/post-commit-quality.py</files>
  <action>
Extend the existing `check_file_complexity()` function in post-commit-quality.py:

1. Add radon import at top (with fallback):
```python
try:
    from radon.complexity import cc_visit
    from radon.metrics import mi_visit
    RADON_AVAILABLE = True
except ImportError:
    RADON_AVAILABLE = False
```

2. Update COMPLEXITY_THRESHOLDS:
```python
COMPLEXITY_THRESHOLDS = {
    "max_lines": 200,
    "max_functions": 10,
    "max_complexity": 10,  # Radon CC grade B cutoff
    "min_maintainability": 10,  # MI grade B cutoff
}
```

3. Extend `check_file_complexity()` to include radon metrics for Python files:
```python
if RADON_AVAILABLE and file_path.suffix in PYTHON_EXTENSIONS:
    try:
        code = file_path.read_text()
        # Cyclomatic complexity
        cc_results = cc_visit(code)
        high_cc = [b for b in cc_results if b.complexity > COMPLEXITY_THRESHOLDS["max_complexity"]]
        if high_cc:
            result["exceeds_threshold"] = True
            result["reasons"].append(f"high complexity: {[f'{b.name}={b.complexity}' for b in high_cc[:3]]}")

        # Maintainability index
        mi = mi_visit(code, multi=True)
        if mi < COMPLEXITY_THRESHOLDS["min_maintainability"]:
            result["exceeds_threshold"] = True
            result["reasons"].append(f"low maintainability: MI={mi:.1f}")
    except Exception:
        pass  # Radon parse error - skip
```

4. Update `generate_quality_message()` to include radon findings in the code-simplifier suggestion.

**Key:** Keep backward compatibility - if radon is not installed, the hook should still work with the original line/function count checks.
  </action>
  <verify>
```bash
python3 /media/sam/1TB/claude-hooks-shared/hooks/quality/post-commit-quality.py < /dev/null
# Should exit 0 (no input = no action)
echo '{"tool_name": "Bash", "tool_input": {"command": "git commit"}, "tool_result": "[main abc123]"}' | python3 /media/sam/1TB/claude-hooks-shared/hooks/quality/post-commit-quality.py 2>/dev/null || true
# Should not crash
```
  </verify>
  <done>post-commit-quality.py includes radon complexity/MI checks for Python files, with graceful fallback</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `validators/design_principles/validator.py` exists with DesignPrinciplesValidator
- [ ] Validator uses radon cc_visit and mi_visit programmatically
- [ ] Validator uses AST for nesting depth and parameter count
- [ ] Orchestrator imports real validator (or graceful fallback)
- [ ] post-commit-quality.py has radon integration
- [ ] All files pass basic import test
</verification>

<success_criteria>

- All tasks completed
- DesignPrinciplesValidator detects complexity violations
- Orchestrator uses real implementation
- post-commit hook triggers code-simplifier on radon violations
- No regressions to existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/09-tier2-validators/09-01-SUMMARY.md`
</output>
