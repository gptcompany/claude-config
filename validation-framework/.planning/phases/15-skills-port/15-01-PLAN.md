---
phase: 15-skills-port
plan: 01
type: execute
wave: 1
depends_on: ["14.6-04"]
files_modified:
  - ~/.claude/settings.json
  - ~/.claude/tdd-guard/data/instructions.md
  - ~/.claude/scripts/statusline/context-monitor.js
  - ~/.claude/scripts/statusline/ui-components.js
autonomous: true
---

<objective>
Integrate existing tdd-guard project and port context-monitor.py to Node.js with improved UI.

Purpose:
1. Leverage the mature tdd-guard project (/media/sam/1TB/tdd-guard) with AI-powered TDD validation
2. Port context-monitor.py to Node.js with enhanced UI (powerline-style, better colors, visual token bar)

Output: tdd-guard integration, context-monitor.js (~400 LOC), ui-components.js (~150 LOC), 25+ tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-skills-port/15-RESEARCH.md
@.planning/phases/15-skills-port/15-CONTEXT.md

# EXISTING tdd-guard project (USE THIS, DON'T REWRITE):
# /media/sam/1TB/tdd-guard/ - Full TypeScript project with:
#   - AI-powered TDD validation (uses Claude/Anthropic)
#   - Multi-language reporters (Vitest, Jest, pytest, PHPUnit, Go, Rust)
#   - npm package: tdd-guard (v1.1.0 installed)
#   - Data dir: ~/.claude/tdd-guard/data/

# Python source to port (context-monitor.py):
@/media/sam/1TB/claude-hooks-shared/scripts/context-monitor.py

# Existing TDD instructions:
@~/.claude/tdd-guard/data/instructions.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify and Configure tdd-guard</name>
  <files>~/.claude/settings.json</files>
  <action>
Verify tdd-guard v1.1.0 is installed and configure Claude Code hooks:

```bash
# Verify installation (already done - v1.1.0 installed)
npm list -g tdd-guard
# Output: ‚îî‚îÄ‚îÄ tdd-guard@1.1.0
```

**Add tdd-guard hook to ~/.claude/settings.json PreToolUse:**
```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Write|Edit|MultiEdit",
        "hooks": [
          {
            "type": "command",
            "command": "tdd-guard",
            "timeout": 10
          }
        ]
      }
    ]
  }
}
```

**Benefits of existing tdd-guard:**
- AI-powered validation (not just pattern matching)
- Multi-language support (JS, TS, Python, PHP, Go, Rust)
- Test result parsing via reporters
- Already handles Red/Green/Refactor phases with AI judgment
- Data stored in ~/.claude/tdd-guard/data/

**DO NOT REWRITE** - use the existing mature project.
  </action>
  <verify>npm list -g tdd-guard && grep -A5 "tdd-guard" ~/.claude/settings.json</verify>
  <done>tdd-guard v1.1.0 installed and configured in settings.json</done>
</task>

<task type="auto">
  <name>Task 2: Create UI Components Library</name>
  <files>~/.claude/scripts/statusline/ui-components.js</files>
  <action>
Create reusable UI components library with powerline-style elements (~150 LOC):

```javascript
#!/usr/bin/env node
/**
 * UI Components for Claude Code Status Line
 * Powerline-style visual elements with rich terminal output
 */

// ANSI color codes
const COLORS = {
  reset: '\x1b[0m',
  bold: '\x1b[1m',
  dim: '\x1b[2m',
  // Foreground
  black: '\x1b[30m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
  gray: '\x1b[90m',
  // Background
  bgBlack: '\x1b[40m',
  bgRed: '\x1b[41m',
  bgGreen: '\x1b[42m',
  bgYellow: '\x1b[43m',
  bgBlue: '\x1b[44m',
  bgMagenta: '\x1b[45m',
  bgCyan: '\x1b[46m',
  bgWhite: '\x1b[47m',
};

// Powerline symbols (Nerd Fonts compatible)
const SYMBOLS = {
  separator: '',      // Powerline separator
  separatorThin: '', // Thin separator
  branch: '',        // Git branch
  folder: '',        // Folder
  tokens: 'Û∞äÑ',        // Brain/tokens
  cost: '',         // Money
  clock: '',         // Time
  lines: '',        // Document
  error: '',         // Error
  warning: '',       // Warning
  success: '',       // Checkmark
  bar: ['‚ñè', '‚ñé', '‚ñç', '‚ñå', '‚ñã', '‚ñä', '‚ñâ', '‚ñà'], // Progress bar chars
};

/**
 * Create a progress bar
 */
function progressBar(percent, width = 8) {
  const filled = Math.round((percent / 100) * width);
  const empty = width - filled;
  return '‚ñà'.repeat(filled) + '‚ñÅ'.repeat(empty);
}

/**
 * Get color based on percentage threshold
 */
function percentColor(percent, thresholds = { low: 50, medium: 75, high: 90 }) {
  if (percent >= thresholds.high) return COLORS.red;
  if (percent >= thresholds.medium) return COLORS.yellow;
  if (percent >= thresholds.low) return COLORS.green;
  return COLORS.cyan;
}

/**
 * Format token count (k/M notation)
 */
function formatTokens(tokens) {
  if (tokens >= 1_000_000) return `${(tokens / 1_000_000).toFixed(1)}M`;
  if (tokens >= 1_000) return `${Math.round(tokens / 1_000)}k`;
  return String(tokens);
}

/**
 * Format cost in USD
 */
function formatCost(costUsd) {
  if (costUsd < 0.01) return `${Math.round(costUsd * 100)}¬¢`;
  return `$${costUsd.toFixed(3)}`;
}

/**
 * Format duration
 */
function formatDuration(ms) {
  if (ms < 60000) return `${Math.round(ms / 1000)}s`;
  return `${Math.round(ms / 60000)}m`;
}

/**
 * Create a powerline segment
 */
function segment(text, fg = COLORS.white, bg = COLORS.bgBlack) {
  return `${bg}${fg} ${text} ${COLORS.reset}`;
}

/**
 * Create a segment with separator
 */
function segmentWithSep(text, fg, bg, nextBg) {
  const sep = nextBg ? `${bg.replace('48', '38')}${nextBg}${SYMBOLS.separator}` : '';
  return `${bg}${fg} ${text} ${COLORS.reset}${sep}`;
}

/**
 * Model badge with context-aware color
 */
function modelBadge(modelName, contextPercent = 0) {
  const color = percentColor(contextPercent);
  return `${color}[${modelName}]${COLORS.reset}`;
}

/**
 * Git branch display
 */
function gitBranch(branch) {
  if (!branch) return '';
  return `${COLORS.magenta}${SYMBOLS.branch} ${branch}${COLORS.reset}`;
}

/**
 * Directory display
 */
function directory(dir) {
  return `${COLORS.yellow}${SYMBOLS.folder} ${dir}${COLORS.reset}`;
}

/**
 * Context usage display with visual bar
 */
function contextUsage(percent, tokens = null) {
  const color = percentColor(percent);
  const bar = progressBar(percent);
  const tokenStr = tokens ? ` ${formatTokens(tokens)}` : '';

  let icon = 'üü¢';
  if (percent >= 95) icon = 'üö®';
  else if (percent >= 90) icon = 'üî¥';
  else if (percent >= 75) icon = 'üü†';
  else if (percent >= 50) icon = 'üü°';

  return `${icon}${color}${bar}${COLORS.reset} ${percent.toFixed(0)}%${tokenStr}`;
}

/**
 * Session metrics (cost, duration, lines)
 */
function sessionMetrics(data) {
  const parts = [];

  if (data.cost > 0) {
    const costColor = data.cost >= 0.10 ? COLORS.red : data.cost >= 0.05 ? COLORS.yellow : COLORS.green;
    parts.push(`${costColor}${SYMBOLS.cost} ${formatCost(data.cost)}${COLORS.reset}`);
  }

  if (data.duration > 0) {
    const durColor = data.duration >= 1800000 ? COLORS.yellow : COLORS.green;
    parts.push(`${durColor}${SYMBOLS.clock} ${formatDuration(data.duration)}${COLORS.reset}`);
  }

  if (data.linesAdded > 0 || data.linesRemoved > 0) {
    const net = data.linesAdded - data.linesRemoved;
    const linesColor = net > 0 ? COLORS.green : net < 0 ? COLORS.red : COLORS.yellow;
    const sign = net >= 0 ? '+' : '';
    parts.push(`${linesColor}${SYMBOLS.lines} ${sign}${net}${COLORS.reset}`);
  }

  return parts.length ? `${COLORS.gray}|${COLORS.reset} ${parts.join(' ')}` : '';
}

module.exports = {
  COLORS,
  SYMBOLS,
  progressBar,
  percentColor,
  formatTokens,
  formatCost,
  formatDuration,
  segment,
  segmentWithSep,
  modelBadge,
  gitBranch,
  directory,
  contextUsage,
  sessionMetrics,
};
```

Make executable and ensure directory exists:
```bash
mkdir -p ~/.claude/scripts/statusline
chmod +x ~/.claude/scripts/statusline/ui-components.js
```
  </action>
  <verify>node -e "const ui = require('$HOME/.claude/scripts/statusline/ui-components'); console.log(ui.formatTokens(45000))"</verify>
  <done>ui-components.js created with powerline-style elements</done>
</task>

<task type="auto">
  <name>Task 3: Port context-monitor.py to Node.js</name>
  <files>~/.claude/scripts/statusline/context-monitor.js</files>
  <action>
Port context-monitor.py to Node.js with improved UI (~400 LOC):

```javascript
#!/usr/bin/env node
/**
 * Claude Code Context Monitor (Node.js Port)
 *
 * DUAL PURPOSE:
 * 1. StatusLine display (real-time, eye-candy) - with improved powerline UI
 * 2. Data persistence (analysis, metrics) - to JSONL + QuestDB
 *
 * Ported from: /media/sam/1TB/claude-hooks-shared/scripts/context-monitor.py
 * Improvements:
 * - Node.js (no Python dependency)
 * - Powerline-style UI with better colors
 * - Nerd Fonts icons
 * - Async QuestDB export
 */

const fs = require('fs');
const path = require('path');
const os = require('os');
const { execSync } = require('child_process');
const net = require('net');

const {
  COLORS,
  modelBadge,
  gitBranch,
  directory,
  contextUsage,
  sessionMetrics,
  formatTokens,
} = require('./ui-components');

// Configuration
const STATS_DIR = path.join(os.homedir(), '.claude', 'stats');
const METRICS_FILE = path.join(STATS_DIR, 'session_metrics.jsonl');
const CONTEXT_WINDOW = 200000; // Assume 200k for Claude

// QuestDB settings
const QUESTDB_HOST = process.env.QUESTDB_HOST || 'localhost';
const QUESTDB_ILP_PORT = parseInt(process.env.QUESTDB_ILP_PORT || '9009');

// ============= Context Parsing =============

function parseContextFromTranscript(transcriptPath) {
  if (!transcriptPath || !fs.existsSync(transcriptPath)) return null;

  try {
    const content = fs.readFileSync(transcriptPath, 'utf8');
    const lines = content.split('\n').filter(l => l.trim());
    const recentLines = lines.slice(-15);

    for (const line of recentLines.reverse()) {
      try {
        const data = JSON.parse(line);

        // Method 1: Parse usage tokens from assistant messages
        if (data.type === 'assistant') {
          const usage = data.message?.usage;
          if (usage) {
            const inputTokens = usage.input_tokens || 0;
            const cacheRead = usage.cache_read_input_tokens || 0;
            const cacheCreation = usage.cache_creation_input_tokens || 0;
            const outputTokens = usage.output_tokens || 0;
            const totalTokens = inputTokens + cacheRead + cacheCreation;

            if (totalTokens > 0) {
              const percentUsed = Math.min(100, (totalTokens / CONTEXT_WINDOW) * 100);
              return {
                percent: percentUsed,
                tokens: totalTokens,
                inputTokens,
                outputTokens,
                cacheCreation,
                cacheRead,
                method: 'usage',
              };
            }
          }
        }

        // Method 2: Parse system context warnings
        if (data.type === 'system_message') {
          const content = data.content || '';

          let match = content.match(/Context left until auto-compact: (\d+)%/);
          if (match) {
            const percentLeft = parseInt(match[1]);
            return { percent: 100 - percentLeft, warning: 'auto-compact', method: 'system' };
          }

          match = content.match(/Context low \((\d+)% remaining\)/);
          if (match) {
            const percentLeft = parseInt(match[1]);
            return { percent: 100 - percentLeft, warning: 'low', method: 'system' };
          }
        }
      } catch {
        continue;
      }
    }
    return null;
  } catch {
    return null;
  }
}

// ============= Context Detection =============

function getGitBranchName() {
  try {
    return execSync('git branch --show-current', { encoding: 'utf8', timeout: 2000 }).trim() || null;
  } catch {
    return null;
  }
}

function getProjectName() {
  try {
    const root = execSync('git rev-parse --show-toplevel', { encoding: 'utf8', timeout: 2000 }).trim();
    return path.basename(root);
  } catch {
    return path.basename(process.cwd());
  }
}

function getTaskContext() {
  // Priority: env var > file > last commit
  if (process.env.CLAUDE_TASK_DESC) return process.env.CLAUDE_TASK_DESC;

  const descFile = path.join(process.cwd(), '.claude', '.session_description');
  if (fs.existsSync(descFile)) {
    try {
      return fs.readFileSync(descFile, 'utf8').trim();
    } catch {}
  }

  try {
    const msg = execSync('git log -1 --pretty=%s', { encoding: 'utf8', timeout: 2000 }).trim();
    return `Commit: ${msg.slice(0, 80)}`;
  } catch {}

  return null;
}

function getAgentName(workspaceData) {
  if (process.env.CLAUDE_AGENT_NAME) return process.env.CLAUDE_AGENT_NAME;

  if (workspaceData?.project_dir) {
    if (workspaceData.project_dir.includes('.claude/agents/') ||
        workspaceData.project_dir.includes('/agents/')) {
      return path.basename(workspaceData.project_dir);
    }
  }
  return null;
}

function getDirectoryDisplay(workspaceData) {
  const currentDir = workspaceData?.current_dir || '';
  const projectDir = workspaceData?.project_dir || '';

  if (currentDir && projectDir && currentDir.startsWith(projectDir)) {
    const relPath = currentDir.slice(projectDir.length).replace(/^\//, '');
    return relPath || path.basename(projectDir);
  }
  return path.basename(currentDir || projectDir || process.cwd());
}

// ============= Persistence =============

function ensureStatsDir() {
  if (!fs.existsSync(STATS_DIR)) {
    fs.mkdirSync(STATS_DIR, { recursive: true });
  }
}

async function exportToQuestDB(metrics) {
  return new Promise((resolve) => {
    try {
      const socket = new net.Socket();
      socket.setTimeout(3000);

      socket.connect(QUESTDB_ILP_PORT, QUESTDB_HOST, () => {
        // ILP format: table,tag=value field=value timestamp
        const project = (metrics.project || 'unknown').replace(/[,= ]/g, '_');
        const branch = (metrics.branch || 'none').replace(/[,= ]/g, '_');

        const line = `claude_sessions,project=${project},branch=${branch} ` +
          `input_tokens=${metrics.inputTokens || 0}i,` +
          `output_tokens=${metrics.outputTokens || 0}i,` +
          `cache_read=${metrics.cacheRead || 0}i,` +
          `cache_creation=${metrics.cacheCreation || 0}i,` +
          `context_percent=${metrics.contextPercent || 0},` +
          `cost_usd=${metrics.costUsd || 0} ` +
          `${Date.now() * 1000000}\n`;

        socket.write(line);
        socket.end();
        resolve(true);
      });

      socket.on('error', () => resolve(false));
      socket.on('timeout', () => { socket.destroy(); resolve(false); });
    } catch {
      resolve(false);
    }
  });
}

function calculateCost(contextInfo, costData) {
  if (costData?.total_cost_usd) return costData.total_cost_usd;

  // Manual calculation (Claude 4.5 Sonnet pricing)
  const inputTokens = contextInfo?.inputTokens || 0;
  const outputTokens = contextInfo?.outputTokens || 0;
  const cacheCreation = contextInfo?.cacheCreation || 0;
  const cacheRead = contextInfo?.cacheRead || 0;

  const costInput = (inputTokens / 1_000_000) * 3.00;
  const costOutput = (outputTokens / 1_000_000) * 15.00;
  const costCacheCreation = (cacheCreation / 1_000_000) * 3.75;
  const costCacheRead = (cacheRead / 1_000_000) * 0.30;

  return costInput + costOutput + costCacheCreation + costCacheRead;
}

function persistMetrics(sessionId, contextInfo, costData, modelName, workspaceData) {
  try {
    ensureStatsDir();

    const branch = getGitBranchName();
    const taskDesc = getTaskContext();
    const agentName = getAgentName(workspaceData);
    const project = getProjectName();

    const metrics = {
      session_id: sessionId,
      timestamp: new Date().toISOString(),
      model: modelName,
      tokens: {
        input: contextInfo?.inputTokens || 0,
        output: contextInfo?.outputTokens || 0,
        cache_creation: contextInfo?.cacheCreation || 0,
        cache_read: contextInfo?.cacheRead || 0,
        total: contextInfo?.tokens || 0,
      },
      context_percent: Math.round((contextInfo?.percent || 0) * 10) / 10,
      cost_usd: Math.round(calculateCost(contextInfo, costData) * 10000) / 10000,
      duration_minutes: costData?.total_duration_ms ? Math.round(costData.total_duration_ms / 60000 * 100) / 100 : 0,
      lines_changed: {
        added: costData?.total_lines_added || 0,
        removed: costData?.total_lines_removed || 0,
      },
      context: {
        git_branch: branch,
        task_description: taskDesc,
        agent_name: agentName,
        working_dir: path.basename(process.cwd()),
        project,
      },
    };

    // Append to JSONL (primary storage)
    fs.appendFileSync(METRICS_FILE, JSON.stringify(metrics) + '\n');

    // Async export to QuestDB (best-effort)
    exportToQuestDB({
      project,
      branch,
      inputTokens: contextInfo?.inputTokens,
      outputTokens: contextInfo?.outputTokens,
      cacheRead: contextInfo?.cacheRead,
      cacheCreation: contextInfo?.cacheCreation,
      contextPercent: contextInfo?.percent,
      costUsd: metrics.cost_usd,
    }).catch(() => {});

    return true;
  } catch {
    return false;
  }
}

// ============= Status Line Display =============

function buildStatusLine(modelName, workspace, contextInfo, costData) {
  const parts = [];

  // Model badge with context-aware color
  parts.push(modelBadge(modelName, contextInfo?.percent || 0));

  // Git branch (if in repo)
  const branch = getGitBranchName();
  if (branch) {
    parts.push(gitBranch(branch));
  }

  // Directory
  parts.push(directory(getDirectoryDisplay(workspace)));

  // Context usage with visual bar
  if (contextInfo) {
    parts.push(`üß† ${contextUsage(contextInfo.percent, contextInfo.tokens)}`);
  } else {
    parts.push(`üß† ${COLORS.blue}???${COLORS.reset}`);
  }

  // Session metrics (cost, duration, lines)
  if (costData || contextInfo) {
    const metricsStr = sessionMetrics({
      cost: calculateCost(contextInfo, costData),
      duration: costData?.total_duration_ms || 0,
      linesAdded: costData?.total_lines_added || 0,
      linesRemoved: costData?.total_lines_removed || 0,
    });
    if (metricsStr) parts.push(metricsStr);
  }

  return parts.join(' ');
}

// ============= Main =============

async function main() {
  try {
    // Read JSON input from Claude Code
    let inputData = '';
    for await (const chunk of process.stdin) {
      inputData += chunk;
    }
    const data = JSON.parse(inputData);

    // Extract information
    const modelName = data.model?.display_name || 'Claude';
    const workspace = data.workspace || {};
    const transcriptPath = data.transcript_path || '';
    const costData = data.cost || {};
    const sessionId = data.session_id || 'unknown';

    // Parse context usage
    const contextInfo = parseContextFromTranscript(transcriptPath);

    // PRIMARY GOAL: Persist metrics with contextual metadata
    if (contextInfo) {
      persistMetrics(sessionId, contextInfo, costData, modelName, workspace);
    }

    // SECONDARY GOAL: Build and output status line
    const statusLine = buildStatusLine(modelName, workspace, contextInfo, costData);
    console.log(statusLine);

  } catch (err) {
    // Fallback display on any error
    const cwd = path.basename(process.cwd());
    console.log(`${COLORS.blue}[Claude]${COLORS.reset} ${COLORS.yellow}üìÅ ${cwd}${COLORS.reset} üß† ${COLORS.red}[Error]${COLORS.reset}`);
  }
}

main();
```

Make executable:
```bash
chmod +x ~/.claude/scripts/statusline/context-monitor.js
```
  </action>
  <verify>echo '{"model":{"display_name":"Opus"},"workspace":{},"cost":{}}' | node ~/.claude/scripts/statusline/context-monitor.js</verify>
  <done>context-monitor.js ported with improved powerline UI</done>
</task>

<task type="auto">
  <name>Task 4: Configure Status Line in settings.json</name>
  <files>~/.claude/settings.json</files>
  <action>
Update settings.json to use the new Node.js context-monitor:

```json
{
  "statusLine": {
    "type": "command",
    "command": "node ~/.claude/scripts/statusline/context-monitor.js"
  }
}
```

Remove or comment out the old Python status line reference.
  </action>
  <verify>grep -A2 "statusLine" ~/.claude/settings.json</verify>
  <done>settings.json updated to use Node.js context-monitor</done>
</task>

<task type="auto">
  <name>Task 5: Create Tests</name>
  <files>~/.claude/scripts/statusline/context-monitor.test.js</files>
  <action>
Create comprehensive test suite (~25 tests):

**UI Components tests (8 tests):**
1. formatTokens handles k notation
2. formatTokens handles M notation
3. formatCost handles cents
4. formatCost handles dollars
5. progressBar shows correct fill
6. percentColor returns correct colors
7. contextUsage shows correct icon
8. sessionMetrics formats all fields

**Context parsing tests (6 tests):**
1. parseContextFromTranscript finds usage data
2. parseContextFromTranscript handles system warnings
3. parseContextFromTranscript returns null on missing file
4. getGitBranchName returns branch
5. getTaskContext reads from env
6. getAgentName detects from path

**Persistence tests (6 tests):**
1. ensureStatsDir creates directory
2. persistMetrics writes to JSONL
3. persistMetrics includes all fields
4. calculateCost uses costData if available
5. calculateCost calculates manually as fallback
6. exportToQuestDB handles connection failure

**Integration tests (5 tests):**
1. Full status line builds correctly
2. Status line handles missing context
3. Status line handles all metrics
4. Fallback works on error
5. End-to-end with mock input

Use temp directories and mock data.
  </action>
  <verify>node --test ~/.claude/scripts/statusline/context-monitor.test.js</verify>
  <done>25 tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] tdd-guard v1.1.0 installed and configured
- [ ] ui-components.js created with powerline elements
- [ ] context-monitor.js ported and working
- [ ] settings.json updated with new statusLine
- [ ] Status bar visible in Claude Code
- [ ] ~/.claude/stats/session_metrics.jsonl being written
- [ ] 25 tests pass
- [ ] Manual test: Start session, verify powerline-style status bar
- [ ] Manual test: Make code change, verify TDD validation runs
</verification>

<success_criteria>
- tdd-guard provides AI-powered TDD enforcement (existing mature project v1.1.0)
- context-monitor.js provides improved status line (powerline-style, better colors)
- Dual storage: local JSONL + QuestDB export
- No Python dependency for status line
- 25+ tests passing
- Visual improvement over Python version
</success_criteria>

<output>
After completion, create `.planning/phases/15-skills-port/15-01-SUMMARY.md`
</output>
