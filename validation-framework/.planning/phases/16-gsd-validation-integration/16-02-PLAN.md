# Plan 16-02: Agent Spawn & Swarm Activation

## Objective

Activate the existing but dormant agent spawn and swarm infrastructure:
- ValidationOrchestrator spawns agents on Tier 2 failures (not just logs)
- Tier 3 validators run in parallel via hive-manager swarm

## Prerequisites

- Plan 16-01 complete (GSD calls orchestrator)
- hive-manager.js accessible (`~/.claude/scripts/hooks/control/`)
- Task tool available for agent spawning

## Current State

### Agent Spawn (Log-only)

```python
# orchestrator.py lines 489-604
if result.agent:
    logger.info(f"  → Spawn agent: {result.agent}")  # LOG ONLY
```

### Swarm (Never invoked)

```javascript
// hive-manager.js - 491 LOC, complete but unused
await hive.spawn(4);
await hive.submit(task);
const results = await hive.collect();
```

## Tasks

### Task 1: Implement Agent Spawn in Orchestrator (8 tests)

**File:** `~/.claude/templates/validation/orchestrator.py`

**Changes:**

1. Add spawn function:
```python
import subprocess
import json

def spawn_agent(agent_type: str, task_description: str, context: dict) -> bool:
    """
    Spawn a Claude Code agent to fix validation issues.

    Args:
        agent_type: Agent type (e.g., 'code-simplifier', 'security-reviewer')
        task_description: What the agent should do
        context: Additional context (file paths, error details)

    Returns:
        True if spawn successful, False otherwise
    """
    try:
        # Use Task tool equivalent via subprocess
        cmd = [
            "claude", "code", "--agent", agent_type,
            "--task", task_description,
            "--context", json.dumps(context)
        ]

        # Fire and forget (non-blocking)
        subprocess.Popen(
            cmd,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            start_new_session=True
        )

        logger.info(f"  → Spawned agent: {agent_type}")
        return True

    except Exception as e:
        logger.warning(f"  → Failed to spawn agent {agent_type}: {e}")
        return False
```

2. Replace log-only with actual spawn:
```python
# In run_tier() method, after Tier 2 failure:
if tier == ValidationTier.WARNING and not result.passed:
    if result.agent:
        spawn_agent(
            agent_type=result.agent,
            task_description=f"Fix: {result.message}",
            context={
                "validator": result.validator_name,
                "failures": result.failures,
                "files": result.affected_files
            }
        )
```

3. Add environment variable control:
```python
AGENT_SPAWN_ENABLED = os.environ.get("VALIDATION_AGENT_SPAWN", "true").lower() == "true"

def spawn_agent(...):
    if not AGENT_SPAWN_ENABLED:
        logger.info(f"  → Agent spawn disabled, would spawn: {agent_type}")
        return False
    # ... actual spawn
```

**Tests:**
- `test_spawn_agent_called_on_tier2_fail`: Spawn called when Tier 2 fails
- `test_spawn_agent_not_called_on_tier1`: Tier 1 doesn't spawn (blocks instead)
- `test_spawn_agent_not_called_on_pass`: No spawn when validation passes
- `test_spawn_agent_respects_env_flag`: VALIDATION_AGENT_SPAWN=false disables
- `test_spawn_agent_correct_context`: Context dict has right fields
- `test_spawn_agent_handles_failure`: Graceful on spawn error
- `test_spawn_agent_nonblocking`: Returns immediately (async)
- `test_spawn_agent_logs_correctly`: Log message format correct

### Task 2: Implement Swarm for Tier 3 (8 tests)

**File:** `~/.claude/templates/validation/orchestrator.py`

**Changes:**

1. Add swarm integration:
```python
import asyncio

async def run_tier3_parallel(validators: list[BaseValidator]) -> list[ValidationResult]:
    """
    Run Tier 3 validators in parallel using swarm workers.

    For Tier 3 (monitoring), parallelization is safe because:
    - Results are non-blocking
    - No ordering dependencies
    - Pure metrics collection
    """
    if len(validators) < 2:
        # Not worth swarm overhead for single validator
        return [await v.validate() for v in validators]

    try:
        # Import hive manager
        hive_script = os.path.expanduser(
            "~/.claude/scripts/hooks/control/hive-manager.js"
        )

        # Initialize swarm with mesh topology
        init_result = subprocess.run(
            ["node", hive_script, "init", "--topology", "mesh"],
            capture_output=True,
            text=True,
            timeout=10
        )

        if init_result.returncode != 0:
            logger.warning("Swarm init failed, falling back to sequential")
            return await run_sequential(validators)

        # Spawn workers (one per validator)
        worker_count = min(len(validators), 4)  # Cap at 4
        subprocess.run(
            ["node", hive_script, "spawn", str(worker_count)],
            timeout=30
        )

        # Submit tasks
        tasks = []
        for v in validators:
            task_id = subprocess.run(
                ["node", hive_script, "submit",
                 "--validator", v.name,
                 "--project", self.project_root],
                capture_output=True,
                text=True
            ).stdout.strip()
            tasks.append(task_id)

        # Collect results
        results = []
        for task_id in tasks:
            result_json = subprocess.run(
                ["node", hive_script, "result", task_id],
                capture_output=True,
                text=True,
                timeout=60
            ).stdout
            results.append(ValidationResult.from_json(result_json))

        # Shutdown swarm
        subprocess.run(["node", hive_script, "shutdown"])

        return results

    except Exception as e:
        logger.warning(f"Swarm execution failed: {e}, falling back to sequential")
        return await run_sequential(validators)
```

2. Update run_tier() for Tier 3:
```python
def run_tier(self, tier: ValidationTier) -> list[ValidationResult]:
    validators = [v for v in self.validators.values() if v.tier == tier]

    if tier == ValidationTier.MONITOR and len(validators) >= 2:
        # Use swarm for Tier 3 parallel execution
        if SWARM_ENABLED:
            return asyncio.run(run_tier3_parallel(validators))

    # Sequential for Tier 1/2 or when swarm disabled
    return [v.validate() for v in validators]
```

3. Add environment control:
```python
SWARM_ENABLED = os.environ.get("VALIDATION_SWARM", "true").lower() == "true"
```

**Tests:**
- `test_swarm_used_for_tier3`: Tier 3 uses swarm when >= 2 validators
- `test_swarm_not_used_for_tier1`: Tier 1 always sequential
- `test_swarm_not_used_for_tier2`: Tier 2 always sequential
- `test_swarm_fallback_on_error`: Falls back to sequential on swarm error
- `test_swarm_caps_workers_at_4`: Never spawns more than 4 workers
- `test_swarm_respects_env_flag`: VALIDATION_SWARM=false disables
- `test_swarm_collects_all_results`: All validator results returned
- `test_swarm_shutdown_called`: Cleanup happens after execution

### Task 3: Update Hive Manager for Validation (4 tests)

**File:** `~/.claude/scripts/hooks/control/hive-manager.js`

**Changes:**

1. Add validation task type:
```javascript
const TASK_TYPES = {
  validation: {
    handler: async (task) => {
      const { validator, project } = task;

      // Run single validator
      const result = await runValidator(validator, project);
      return result;
    },
    timeout: 60000  // 1 minute per validator
  }
};

async function runValidator(validatorName, projectPath) {
  const { spawn } = require('child_process');

  return new Promise((resolve, reject) => {
    const proc = spawn('python3', [
      path.join(process.env.HOME, '.claude/templates/validation/orchestrator.py'),
      '--validator', validatorName,
      '--project', projectPath,
      '--json'
    ]);

    let output = '';
    proc.stdout.on('data', (data) => output += data);
    proc.on('close', (code) => {
      try {
        resolve(JSON.parse(output));
      } catch (e) {
        reject(e);
      }
    });
  });
}
```

2. Add result collection endpoint:
```javascript
function collectResults(taskIds) {
  return taskIds.map(id => state.tasks[id]?.result || null);
}
```

**Tests:**
- `test_hive_validation_task_type`: Validation tasks recognized
- `test_hive_runs_single_validator`: Correct validator invoked
- `test_hive_returns_json_result`: Result parsed correctly
- `test_hive_handles_validator_timeout`: Timeout returns error result

## Acceptance Criteria

- [ ] Agent spawn actually executes (not just logs)
- [ ] VALIDATION_AGENT_SPAWN flag controls behavior
- [ ] Tier 3 runs in parallel when >= 2 validators
- [ ] Swarm falls back to sequential on error
- [ ] VALIDATION_SWARM flag controls behavior
- [ ] Hive manager supports validation task type
- [ ] 20 tests pass (8 + 8 + 4)

## Files Modified

- `~/.claude/templates/validation/orchestrator.py`
- `~/.claude/scripts/hooks/control/hive-manager.js`
- `tests/unit/test_agent_spawn.py` (new)
- `tests/unit/test_swarm_validation.py` (new)

## Estimated Effort

- Task 1: 1 hour
- Task 2: 1.5 hours
- Task 3: 30 min
- **Total: ~3 hours**
