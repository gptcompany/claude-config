"""
Risk Limit Enforcement Tests

Project: {{ project_name }}
Domain: {{ domain }}
Auto-generated by validation framework.

Tests risk limit enforcement including position size limits,
drawdown thresholds, VaR limits, and circuit breaker behavior.
"""
{% if domain == "trading" %}
from __future__ import annotations

import pytest


@pytest.mark.trading
class TestRiskLimits:
    """Verify risk limits are enforced correctly."""

    def test_max_position_size(self, risk_manager) -> None:
        """Position size limits enforced."""
        # Get configured max position size
        max_size = risk_manager.get_limit("max_position_size")
        assert max_size is not None and max_size > 0

        # Attempt to exceed position limit
        result = risk_manager.check_position_size(
            symbol="BTC/USDT",
            proposed_quantity=max_size * 2,
        )
        assert result.allowed is False
        assert "position" in result.reason.lower() or "size" in result.reason.lower()

        # Within limit should pass
        result = risk_manager.check_position_size(
            symbol="BTC/USDT",
            proposed_quantity=max_size * 0.5,
        )
        assert result.allowed is True

    def test_max_drawdown_threshold(self, risk_manager) -> None:
        """Drawdown triggers halt when threshold exceeded."""
        {% if rollback_triggers %}
        {% for trigger in rollback_triggers %}
        {% if trigger.metric == "drawdown_pct" %}
        threshold = {{ trigger.threshold }}
        {% endif %}
        {% endfor %}
        {% else %}
        threshold = 10.0  # Default 10% drawdown threshold
        {% endif %}

        # Simulate drawdown exceeding threshold
        risk_manager.set_current_drawdown(threshold + 1.0)
        status = risk_manager.get_trading_status()

        assert status.halted is True
        assert "drawdown" in status.halt_reason.lower()

        # Below threshold should not halt
        risk_manager.set_current_drawdown(threshold * 0.5)
        status = risk_manager.get_trading_status()
        assert status.halted is False

    def test_var_threshold(self, risk_manager) -> None:
        """VaR limit triggers risk reduction when exceeded."""
        {% if rollback_triggers %}
        {% for trigger in rollback_triggers %}
        {% if trigger.metric == "var_pct" %}
        threshold = {{ trigger.threshold }}
        {% endif %}
        {% endfor %}
        {% else %}
        threshold = 5.0  # Default 5% VaR threshold
        {% endif %}

        # Simulate VaR exceeding threshold
        risk_manager.set_current_var(threshold + 1.0)
        action = risk_manager.get_recommended_action()

        assert action.reduce_exposure is True
        assert action.reduction_pct > 0

        # Below threshold should not require reduction
        risk_manager.set_current_var(threshold * 0.5)
        action = risk_manager.get_recommended_action()
        assert action.reduce_exposure is False

    def test_daily_loss_limit(self, risk_manager) -> None:
        """Daily P&L limit enforced."""
        max_daily_loss = risk_manager.get_limit("max_daily_loss")
        assert max_daily_loss is not None

        # Simulate exceeding daily loss
        risk_manager.set_daily_pnl(-abs(max_daily_loss) - 100)
        status = risk_manager.get_trading_status()

        assert status.halted is True
        assert "daily" in status.halt_reason.lower() or "loss" in status.halt_reason.lower()


@pytest.mark.trading
class TestRiskLimitConfiguration:
    """Verify risk limit configuration works correctly."""

    def test_limits_from_config(self, risk_manager, validation_config) -> None:
        """Limits load from config correctly."""
        # Verify risk manager has loaded limits
        limits = risk_manager.get_all_limits()
        assert limits is not None
        assert len(limits) > 0

        # Check expected limit types exist
        expected_limits = ["max_position_size", "max_daily_loss"]
        for limit_name in expected_limits:
            assert limit_name in limits or risk_manager.get_limit(limit_name) is not None

    def test_limit_update_propagation(self, risk_manager) -> None:
        """Runtime limit updates apply immediately."""
        original_limit = risk_manager.get_limit("max_position_size")

        # Update limit
        new_limit = original_limit * 0.5
        risk_manager.update_limit("max_position_size", new_limit)

        # Verify update propagated
        current_limit = risk_manager.get_limit("max_position_size")
        assert current_limit == pytest.approx(new_limit, rel=1e-6)

        # Restore original
        risk_manager.update_limit("max_position_size", original_limit)


@pytest.mark.trading
class TestCircuitBreaker:
    """Verify circuit breaker behavior."""

    def test_circuit_breaker_triggers(self, risk_manager) -> None:
        """Circuit breaker activates on threshold breach."""
        # Get circuit breaker config
        cb_config = risk_manager.get_circuit_breaker_config()
        assert cb_config is not None
        assert cb_config.enabled is True

        # Trigger circuit breaker
        risk_manager.simulate_rapid_losses(count=cb_config.trigger_count)

        status = risk_manager.get_circuit_breaker_status()
        assert status.tripped is True
        assert status.state in ("OPEN", "HALTED")

    def test_circuit_breaker_recovery(self, risk_manager) -> None:
        """Circuit breaker recovers after cooldown."""
        cb_config = risk_manager.get_circuit_breaker_config()

        # Trip circuit breaker
        risk_manager.simulate_rapid_losses(count=cb_config.trigger_count)
        assert risk_manager.get_circuit_breaker_status().tripped is True

        # Simulate cooldown period
        risk_manager.advance_time(seconds=cb_config.cooldown_seconds + 1)

        # Should recover
        status = risk_manager.get_circuit_breaker_status()
        assert status.tripped is False
        assert status.state in ("CLOSED", "HALF_OPEN", "ACTIVE")

    def test_circuit_breaker_half_open(self, risk_manager) -> None:
        """Circuit breaker enters half-open state before full recovery."""
        cb_config = risk_manager.get_circuit_breaker_config()

        # Trip and wait for partial cooldown
        risk_manager.simulate_rapid_losses(count=cb_config.trigger_count)
        risk_manager.advance_time(seconds=cb_config.cooldown_seconds)

        status = risk_manager.get_circuit_breaker_status()
        # Should be in half-open or closed state
        assert status.state in ("HALF_OPEN", "CLOSED", "ACTIVE")
{% else %}
# Skipped: domain is not "trading" (domain={{ domain }})
# This template only generates tests when domain == "trading"

import pytest


@pytest.mark.skip(reason="Trading domain tests not enabled (domain={{ domain }})")
def test_placeholder() -> None:
    """Placeholder test - trading domain not enabled."""
    pass
{% endif %}
