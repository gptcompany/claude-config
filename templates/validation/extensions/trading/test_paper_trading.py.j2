"""
Paper Trading Execution Tests

Project: {{ project_name }}
Domain: {{ domain }}
Auto-generated by validation framework.

Tests paper trading execution behavior including order submission,
fill simulation, position tracking, and balance updates.
"""
{% if domain == "trading" %}
from __future__ import annotations

import pytest


@pytest.mark.trading
class TestPaperTradingExecution:
    """Verify paper trading execution works correctly."""

    def test_order_submission(self, paper_trading_client) -> None:
        """Orders submit without error."""
        order = paper_trading_client.submit_order(
            symbol="BTC/USDT",
            side="buy",
            quantity=0.1,
            order_type="market",
        )
        assert order is not None
        assert order.status in ("submitted", "pending", "filled")
        assert order.symbol == "BTC/USDT"

    def test_order_fill_simulation(self, paper_trading_client) -> None:
        """Simulated fills return expected structure."""
        order = paper_trading_client.submit_order(
            symbol="ETH/USDT",
            side="buy",
            quantity=1.0,
            order_type="market",
        )
        # Wait for fill simulation
        fill = paper_trading_client.wait_for_fill(order.id, timeout=5.0)

        assert fill is not None
        assert fill.order_id == order.id
        assert fill.quantity > 0
        assert fill.price > 0
        assert fill.timestamp is not None

    def test_position_tracking(self, paper_trading_client) -> None:
        """Positions update after fills."""
        initial_position = paper_trading_client.get_position("BTC/USDT")
        initial_qty = initial_position.quantity if initial_position else 0.0

        # Submit and fill order
        order = paper_trading_client.submit_order(
            symbol="BTC/USDT",
            side="buy",
            quantity=0.5,
            order_type="market",
        )
        paper_trading_client.wait_for_fill(order.id, timeout=5.0)

        # Check position updated
        updated_position = paper_trading_client.get_position("BTC/USDT")
        assert updated_position is not None
        assert updated_position.quantity == pytest.approx(initial_qty + 0.5, rel=1e-6)

    def test_balance_updates(self, paper_trading_client) -> None:
        """Balance reflects P&L after trades."""
        initial_balance = paper_trading_client.get_balance("USDT")
        assert initial_balance > 0

        # Submit buy order
        order = paper_trading_client.submit_order(
            symbol="BTC/USDT",
            side="buy",
            quantity=0.1,
            order_type="market",
        )
        fill = paper_trading_client.wait_for_fill(order.id, timeout=5.0)

        # Balance should decrease by fill value
        updated_balance = paper_trading_client.get_balance("USDT")
        expected_cost = fill.price * fill.quantity
        assert updated_balance == pytest.approx(initial_balance - expected_cost, rel=1e-4)


@pytest.mark.trading
class TestPaperTradingEdgeCases:
    """Verify paper trading handles edge cases correctly."""

    def test_insufficient_balance(self, paper_trading_client) -> None:
        """Order rejected when balance insufficient."""
        # Try to buy more than balance allows
        huge_quantity = 999999.0

        with pytest.raises(Exception) as exc_info:
            paper_trading_client.submit_order(
                symbol="BTC/USDT",
                side="buy",
                quantity=huge_quantity,
                order_type="market",
            )

        # Should raise insufficient balance error
        assert "insufficient" in str(exc_info.value).lower() or \
               "balance" in str(exc_info.value).lower()

    def test_invalid_symbol(self, paper_trading_client) -> None:
        """Order rejected for unknown symbols."""
        with pytest.raises(Exception) as exc_info:
            paper_trading_client.submit_order(
                symbol="INVALID/PAIR",
                side="buy",
                quantity=1.0,
                order_type="market",
            )

        # Should raise invalid symbol error
        assert "symbol" in str(exc_info.value).lower() or \
               "invalid" in str(exc_info.value).lower() or \
               "unknown" in str(exc_info.value).lower()

    def test_zero_quantity(self, paper_trading_client) -> None:
        """Order rejected for zero or negative quantity."""
        with pytest.raises(Exception) as exc_info:
            paper_trading_client.submit_order(
                symbol="BTC/USDT",
                side="buy",
                quantity=0.0,
                order_type="market",
            )

        assert "quantity" in str(exc_info.value).lower() or \
               "zero" in str(exc_info.value).lower() or \
               "invalid" in str(exc_info.value).lower()

    def test_negative_quantity(self, paper_trading_client) -> None:
        """Order rejected for negative quantity."""
        with pytest.raises(Exception) as exc_info:
            paper_trading_client.submit_order(
                symbol="BTC/USDT",
                side="buy",
                quantity=-1.0,
                order_type="market",
            )

        assert "quantity" in str(exc_info.value).lower() or \
               "negative" in str(exc_info.value).lower() or \
               "invalid" in str(exc_info.value).lower()
{% else %}
# Skipped: domain is not "trading" (domain={{ domain }})
# This template only generates tests when domain == "trading"

import pytest


@pytest.mark.skip(reason="Trading domain tests not enabled (domain={{ domain }})")
def test_placeholder() -> None:
    """Placeholder test - trading domain not enabled."""
    pass
{% endif %}
