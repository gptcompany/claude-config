"""
Workflow Node Connection Tests

Project: {{ project_name }}
Domain: {{ domain }}
Auto-generated by validation framework.

Tests workflow node connectivity including reachability, credentials,
API compatibility, and data flow between nodes.
"""
{% if domain == "workflow" %}
from __future__ import annotations

import pytest


@pytest.mark.workflow
class TestNodeConnections:
    """Verify workflow nodes are reachable and configured correctly."""

    def test_nodes_reachable(self, node_client, workflow_nodes) -> None:
        """All configured nodes respond."""
        for node in workflow_nodes:
            result = node_client.ping(node.id)
            assert result.reachable, f"Node {node.id} ({node.name}) is not reachable"
            assert result.response_time_ms < 5000, (
                f"Node {node.id} response time too slow: {result.response_time_ms}ms"
            )

    def test_node_credentials_valid(self, node_client, workflow_nodes) -> None:
        """Node credentials authenticate successfully."""
        for node in workflow_nodes:
            if not node.requires_auth:
                continue

            auth_result = node_client.authenticate(node.id)
            assert auth_result.authenticated, (
                f"Node {node.id} ({node.name}) authentication failed: {auth_result.error}"
            )
            assert auth_result.token is not None or auth_result.session_valid

    def test_node_api_version(self, node_client, workflow_nodes) -> None:
        """Node API version compatible with workflow requirements."""
        for node in workflow_nodes:
            version_info = node_client.get_api_version(node.id)
            assert version_info is not None, f"Node {node.id} did not return version info"

            # Check minimum version if specified
            if node.min_api_version:
                assert version_info.version >= node.min_api_version, (
                    f"Node {node.id} API version {version_info.version} "
                    f"below minimum {node.min_api_version}"
                )

    def test_node_rate_limits(self, node_client, workflow_nodes) -> None:
        """Rate limit headers respected."""
        for node in workflow_nodes:
            rate_info = node_client.get_rate_limit_info(node.id)

            if rate_info.has_rate_limit:
                assert rate_info.remaining >= 0, (
                    f"Node {node.id} rate limit exhausted"
                )
                assert rate_info.limit > 0, (
                    f"Node {node.id} has invalid rate limit: {rate_info.limit}"
                )


@pytest.mark.workflow
class TestNodeIntegration:
    """Verify nodes work together correctly in workflows."""

    def test_node_to_node_data_flow(self, workflow_client, workflow_nodes) -> None:
        """Data passes between connected nodes."""
        # Find a workflow with connected nodes
        execution = workflow_client.trigger_workflow(
            workflow_id="data-flow-test-workflow",
            input_data={"test_data": "hello_world"},
        )

        result = workflow_client.wait_for_completion(
            execution_id=execution.execution_id,
            timeout=30.0,
        )

        assert result.status == "completed"
        # Verify data flowed through nodes
        assert result.output is not None
        assert result.node_outputs is not None
        assert len(result.node_outputs) > 1, "Expected multiple node outputs"

        # Each node should have received and passed data
        for node_id, output in result.node_outputs.items():
            assert output is not None, f"Node {node_id} had no output"

    def test_parallel_node_execution(self, workflow_client) -> None:
        """Parallel node execution completes."""
        execution = workflow_client.trigger_workflow(
            workflow_id="parallel-nodes-workflow",
            input_data={"branch_count": 3},
        )

        result = workflow_client.wait_for_completion(
            execution_id=execution.execution_id,
            timeout=60.0,
        )

        assert result.status == "completed"
        assert result.error is None

        # Verify all parallel branches executed
        assert result.execution_stats is not None
        assert result.execution_stats.parallel_branches_executed >= 3

    def test_conditional_node_routing(self, workflow_client) -> None:
        """Conditional branches execute correctly."""
        # Test true condition path
        true_execution = workflow_client.trigger_workflow(
            workflow_id="conditional-workflow",
            input_data={"condition_value": True},
        )

        true_result = workflow_client.wait_for_completion(
            execution_id=true_execution.execution_id,
            timeout=30.0,
        )

        assert true_result.status == "completed"
        assert true_result.output.get("branch_taken") == "true_branch"

        # Test false condition path
        false_execution = workflow_client.trigger_workflow(
            workflow_id="conditional-workflow",
            input_data={"condition_value": False},
        )

        false_result = workflow_client.wait_for_completion(
            execution_id=false_execution.execution_id,
            timeout=30.0,
        )

        assert false_result.status == "completed"
        assert false_result.output.get("branch_taken") == "false_branch"
{% else %}
# Skipped: domain is not "workflow" (domain={{ domain }})
# This template only generates tests when domain == "workflow"

import pytest


@pytest.mark.skip(reason="Workflow domain tests not enabled (domain={{ domain }})")
def test_placeholder() -> None:
    """Placeholder test - workflow domain not enabled."""
    pass
{% endif %}
