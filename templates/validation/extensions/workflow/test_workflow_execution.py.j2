"""
Workflow Execution Tests

Project: {{ project_name }}
Domain: {{ domain }}
Auto-generated by validation framework.

Tests workflow execution behavior including triggers, completion,
output validation, and timeout handling.
"""
{% if domain == "workflow" %}
from __future__ import annotations

import pytest


@pytest.mark.workflow
class TestWorkflowExecution:
    """Verify workflow execution works correctly."""

    def test_workflow_triggers(self, workflow_client) -> None:
        """Workflow can be triggered via API."""
        result = workflow_client.trigger_workflow(
            workflow_id="test-workflow",
            input_data={"test": True},
        )
        assert result is not None
        assert result.execution_id is not None
        assert result.status in ("queued", "running", "completed")

    def test_workflow_completes(self, workflow_client) -> None:
        """Workflow runs to completion without error."""
        execution = workflow_client.trigger_workflow(
            workflow_id="test-workflow",
            input_data={"test": True},
        )

        # Wait for workflow to complete
        final_status = workflow_client.wait_for_completion(
            execution_id=execution.execution_id,
            timeout=30.0,
        )

        assert final_status.status == "completed"
        assert final_status.error is None

    def test_workflow_output_structure(self, workflow_client) -> None:
        """Workflow output matches expected schema."""
        execution = workflow_client.trigger_workflow(
            workflow_id="test-workflow",
            input_data={"test": True},
        )

        result = workflow_client.wait_for_completion(
            execution_id=execution.execution_id,
            timeout=30.0,
        )

        # Verify output structure
        assert result.output is not None
        assert isinstance(result.output, dict)
        # Output should contain expected fields based on workflow definition
        assert "success" in result.output or "result" in result.output

    def test_workflow_timeout_handling(self, workflow_client) -> None:
        """Workflow respects timeout configuration."""
        # Trigger workflow with custom timeout
        execution = workflow_client.trigger_workflow(
            workflow_id="timeout-test-workflow",
            input_data={"simulate_delay": True},
            timeout=5,  # Short timeout
        )

        # Workflow should either complete quickly or timeout
        result = workflow_client.wait_for_completion(
            execution_id=execution.execution_id,
            timeout=10.0,
        )

        # Either completed successfully or timed out with proper status
        assert result.status in ("completed", "timeout", "cancelled")
        if result.status == "timeout":
            assert result.error is not None
            assert "timeout" in result.error.lower()


@pytest.mark.workflow
class TestWorkflowErrorHandling:
    """Verify workflow handles errors correctly."""

    def test_invalid_input_rejection(self, workflow_client) -> None:
        """Malformed input rejected with clear error."""
        with pytest.raises(Exception) as exc_info:
            workflow_client.trigger_workflow(
                workflow_id="test-workflow",
                input_data="invalid-not-a-dict",  # Should be dict
            )

        assert "input" in str(exc_info.value).lower() or \
               "invalid" in str(exc_info.value).lower() or \
               "type" in str(exc_info.value).lower()

    def test_missing_credentials_handled(self, workflow_client) -> None:
        """Graceful error when credentials missing."""
        # Trigger workflow that requires external credentials
        execution = workflow_client.trigger_workflow(
            workflow_id="external-api-workflow",
            input_data={"test": True},
            credentials={},  # Empty credentials
        )

        result = workflow_client.wait_for_completion(
            execution_id=execution.execution_id,
            timeout=10.0,
        )

        # Should fail gracefully with credential error
        if result.status == "failed":
            assert result.error is not None
            assert "credential" in result.error.lower() or \
                   "auth" in result.error.lower() or \
                   "unauthorized" in result.error.lower()

    def test_retry_on_transient_failure(self, workflow_client) -> None:
        """Retry logic for transient failures."""
        execution = workflow_client.trigger_workflow(
            workflow_id="flaky-workflow",
            input_data={"simulate_transient_failure": True},
            retry_config={"max_retries": 3, "backoff": "exponential"},
        )

        result = workflow_client.wait_for_completion(
            execution_id=execution.execution_id,
            timeout=60.0,
        )

        # Workflow should eventually succeed after retries
        # or fail with retry exhaustion message
        assert result.status in ("completed", "failed")
        if result.status == "completed":
            assert result.retry_count >= 0
        else:
            assert result.error is not None
            assert "retry" in result.error.lower() or \
                   "exhausted" in result.error.lower()
{% else %}
# Skipped: domain is not "workflow" (domain={{ domain }})
# This template only generates tests when domain == "workflow"

import pytest


@pytest.mark.skip(reason="Workflow domain tests not enabled (domain={{ domain }})")
def test_placeholder() -> None:
    """Placeholder test - workflow domain not enabled."""
    pass
{% endif %}
