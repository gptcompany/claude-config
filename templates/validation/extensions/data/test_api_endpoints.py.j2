"""
API Endpoint Tests

Project: {{ project_name }}
Domain: {{ domain }}
Auto-generated by validation framework.

Tests API endpoint behavior including health checks, authentication,
rate limiting, CRUD operations, and error handling.
"""
{% if domain == "data" %}
from __future__ import annotations

import pytest


@pytest.mark.data
class TestAPIEndpoints:
    """Verify API endpoints work correctly."""

    def test_health_endpoint(self, api_client) -> None:
        """Health endpoint returns 200."""
        response = api_client.get("/health")
        assert response.status_code == 200
        assert response.json() is not None

        # Health response should indicate service status
        data = response.json()
        assert "status" in data or "healthy" in data
        if "status" in data:
            assert data["status"] in ("ok", "healthy", "up")

    def test_api_authentication(self, api_client, auth_token) -> None:
        """Auth-required endpoints reject unauthenticated requests."""
        # Request without auth should fail
        response = api_client.get("/protected/resource")
        assert response.status_code in (401, 403), (
            f"Expected 401/403 for unauthenticated request, got {response.status_code}"
        )

        # Request with valid auth should succeed
        response = api_client.get(
            "/protected/resource",
            headers={"Authorization": f"Bearer {auth_token}"},
        )
        assert response.status_code == 200

    def test_rate_limiting(self, api_client) -> None:
        """Rate limit headers present and enforced."""
        response = api_client.get("/health")

        # Check rate limit headers
        rate_limit_headers = [
            "X-RateLimit-Limit",
            "X-RateLimit-Remaining",
            "RateLimit-Limit",
            "RateLimit-Remaining",
        ]

        has_rate_limit = any(
            header in response.headers
            for header in rate_limit_headers
        )

        if has_rate_limit:
            # Verify rate limit is reasonable
            limit_header = next(
                (h for h in rate_limit_headers if h in response.headers),
                None,
            )
            if limit_header:
                limit = int(response.headers[limit_header])
                assert limit > 0, "Rate limit should be positive"

    def test_response_format(self, api_client) -> None:
        """JSON responses match API spec."""
        response = api_client.get("/health")

        # Should return JSON
        assert "application/json" in response.headers.get("Content-Type", ""), (
            f"Expected JSON content type, got {response.headers.get('Content-Type')}"
        )

        # Should be parseable JSON
        try:
            data = response.json()
            assert isinstance(data, (dict, list)), "Response should be JSON object or array"
        except ValueError as e:
            pytest.fail(f"Response is not valid JSON: {e}")


@pytest.mark.data
class TestAPICRUD:
    """Verify CRUD operations work correctly."""

    def test_list_endpoint(self, api_client, auth_token) -> None:
        """GET /resource returns paginated list."""
        response = api_client.get(
            "/resources",
            headers={"Authorization": f"Bearer {auth_token}"},
        )

        assert response.status_code == 200
        data = response.json()

        # Should be a list or contain a data array
        if isinstance(data, dict):
            assert "data" in data or "items" in data or "results" in data, (
                "Paginated response should have data/items/results key"
            )
            items = data.get("data") or data.get("items") or data.get("results")
            assert isinstance(items, list)
        else:
            assert isinstance(data, list)

    def test_get_by_id(self, api_client, auth_token, test_resource_id) -> None:
        """GET /resource/:id returns single item."""
        response = api_client.get(
            f"/resources/{test_resource_id}",
            headers={"Authorization": f"Bearer {auth_token}"},
        )

        assert response.status_code == 200
        data = response.json()
        assert isinstance(data, dict)
        assert "id" in data or "_id" in data
        resource_id = data.get("id") or data.get("_id")
        assert str(resource_id) == str(test_resource_id)

    def test_create_endpoint(self, api_client, auth_token) -> None:
        """POST /resource creates item."""
        new_resource = {
            "name": "test-resource",
            "description": "Created by test",
        }

        response = api_client.post(
            "/resources",
            json=new_resource,
            headers={"Authorization": f"Bearer {auth_token}"},
        )

        assert response.status_code in (200, 201), (
            f"Expected 200/201 for create, got {response.status_code}"
        )
        data = response.json()
        assert "id" in data or "_id" in data, "Created resource should have ID"

    def test_update_endpoint(self, api_client, auth_token, test_resource_id) -> None:
        """PUT /resource/:id updates item."""
        updated_data = {
            "name": "updated-resource",
            "description": "Updated by test",
        }

        response = api_client.put(
            f"/resources/{test_resource_id}",
            json=updated_data,
            headers={"Authorization": f"Bearer {auth_token}"},
        )

        assert response.status_code == 200
        data = response.json()
        assert data.get("name") == "updated-resource" or data.get("updated") is True

    def test_delete_endpoint(self, api_client, auth_token, test_resource_id) -> None:
        """DELETE /resource/:id removes item."""
        response = api_client.delete(
            f"/resources/{test_resource_id}",
            headers={"Authorization": f"Bearer {auth_token}"},
        )

        assert response.status_code in (200, 204), (
            f"Expected 200/204 for delete, got {response.status_code}"
        )

        # Verify resource is gone
        get_response = api_client.get(
            f"/resources/{test_resource_id}",
            headers={"Authorization": f"Bearer {auth_token}"},
        )
        assert get_response.status_code == 404


@pytest.mark.data
class TestAPIErrorHandling:
    """Verify API error responses are correct."""

    def test_404_for_missing_resource(self, api_client, auth_token) -> None:
        """Proper 404 response for missing resource."""
        response = api_client.get(
            "/resources/nonexistent-id-12345",
            headers={"Authorization": f"Bearer {auth_token}"},
        )

        assert response.status_code == 404
        data = response.json()

        # Should have error message
        assert "error" in data or "message" in data or "detail" in data

    def test_400_for_invalid_input(self, api_client, auth_token) -> None:
        """Validation error response format correct."""
        invalid_resource = {
            "name": "",  # Empty name should fail validation
            # Missing required fields
        }

        response = api_client.post(
            "/resources",
            json=invalid_resource,
            headers={"Authorization": f"Bearer {auth_token}"},
        )

        assert response.status_code in (400, 422), (
            f"Expected 400/422 for validation error, got {response.status_code}"
        )
        data = response.json()

        # Should have error details
        assert "error" in data or "errors" in data or "detail" in data or "message" in data

    def test_500_error_format(self, api_client) -> None:
        """Server errors don't leak internals."""
        # Hit an endpoint that might trigger server error
        # (e.g., malformed request that bypasses validation)
        response = api_client.post(
            "/resources",
            data="not-json",  # Invalid content type
            headers={"Content-Type": "application/json"},
        )

        if response.status_code >= 500:
            data = response.json() if response.headers.get("Content-Type", "").startswith("application/json") else {}

            # Should not contain stack traces or internal paths
            response_text = str(data)
            assert "Traceback" not in response_text, "Error response contains stack trace"
            assert "/home/" not in response_text, "Error response contains system paths"
            assert "/var/" not in response_text, "Error response contains system paths"
{% else %}
# Skipped: domain is not "data" (domain={{ domain }})
# This template only generates tests when domain == "data"

import pytest


@pytest.mark.skip(reason="Data domain tests not enabled (domain={{ domain }})")
def test_placeholder() -> None:
    """Placeholder test - data domain not enabled."""
    pass
{% endif %}
